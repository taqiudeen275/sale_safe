// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Category.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Category TABLE
class TableCategory extends SqfEntityTableBase {
  TableCategory() {
    // declare properties of EntityTable
    tableName = 'category';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCategory();
  }
}

// Product TABLE
class TableProduct extends SqfEntityTableBase {
  TableProduct() {
    // declare properties of EntityTable
    tableName = 'product';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('cost', DbType.real),
      SqfEntityFieldBase('price', DbType.real),
      SqfEntityFieldBase('quantity', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableCategory.getInstance, DeleteRule.SET_NULL,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'categoryId',
          defaultValue: 0),
      SqfEntityFieldBase('reference', DbType.integer),
      SqfEntityFieldBase('image_url', DbType.text),
      SqfEntityFieldBase('expiry_date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProduct();
  }
}

// Lead TABLE
class TableLead extends SqfEntityTableBase {
  TableLead() {
    // declare properties of EntityTable
    tableName = 'lead';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('email', DbType.text),
      SqfEntityFieldBase('phone', DbType.text),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLead();
  }
}

// Supplier TABLE
class TableSupplier extends SqfEntityTableBase {
  TableSupplier() {
    // declare properties of EntityTable
    tableName = 'supplier';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('email', DbType.text),
      SqfEntityFieldBase('phone', DbType.text),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSupplier();
  }
}

// PaymentMethod TABLE
class TablePaymentMethod extends SqfEntityTableBase {
  TablePaymentMethod() {
    // declare properties of EntityTable
    tableName = 'paymentMethods';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePaymentMethod();
  }
}

// PaymentDetail TABLE
class TablePaymentDetail extends SqfEntityTableBase {
  TablePaymentDetail() {
    // declare properties of EntityTable
    tableName = 'paymentDetails';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TablePaymentMethod.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'paymentMethodsId',
          defaultValue: 0),
      SqfEntityFieldBase('details', DbType.text),
      SqfEntityFieldBase('date', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePaymentDetail();
  }
}

// Order TABLE
class TableOrder extends SqfEntityTableBase {
  TableOrder() {
    // declare properties of EntityTable
    tableName = 'orders';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(TableSale.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'salesId',
          defaultValue: 0),
      SqfEntityFieldRelationshipBase(
          TableProduct.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'productId',
          defaultValue: 0),
      SqfEntityFieldBase('quantity', DbType.integer),
      SqfEntityFieldBase('amount', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableOrder();
  }
}

// Invoice TABLE
class TableInvoice extends SqfEntityTableBase {
  TableInvoice() {
    // declare properties of EntityTable
    tableName = 'invoice';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(TableSale.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'salesId',
          defaultValue: 0),
      SqfEntityFieldBase('customer_name', DbType.text),
      SqfEntityFieldBase('invoice_number', DbType.text),
      SqfEntityFieldBase('amount', DbType.real),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoice();
  }
}

// Payment TABLE
class TablePayment extends SqfEntityTableBase {
  TablePayment() {
    // declare properties of EntityTable
    tableName = 'payment';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('number', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TablePaymentMethod.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'paymentMethodsId',
          defaultValue: 0),
      SqfEntityFieldRelationshipBase(TableSale.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'sale',
          defaultValue: 0),
      SqfEntityFieldBase('amount', DbType.real),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePayment();
  }
}

// Sale TABLE
class TableSale extends SqfEntityTableBase {
  TableSale() {
    // declare properties of EntityTable
    tableName = 'sales';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('isCredit', DbType.bool),
      SqfEntityFieldBase('amount', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSale();
  }
}

// Period TABLE
class TablePeriod extends SqfEntityTableBase {
  TablePeriod() {
    // declare properties of EntityTable
    tableName = 'period';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('start_date', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('end_date', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePeriod();
  }
}

// Expense TABLE
class TableExpense extends SqfEntityTableBase {
  TableExpense() {
    // declare properties of EntityTable
    tableName = 'expense';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('amount', DbType.real),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpense();
  }
}

// ProfitAndLoss TABLE
class TableProfitAndLoss extends SqfEntityTableBase {
  TableProfitAndLoss() {
    // declare properties of EntityTable
    tableName = 'profitAndLoss';
    relationType = RelationType.ONE_TO_ONE;
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TablePeriod.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_ONE,
          fieldName: '_periodId',
          defaultValue: 0),
      SqfEntityFieldBase('revenue', DbType.real),
      SqfEntityFieldBase('cost', DbType.real),
      SqfEntityFieldBase('expense', DbType.real),
      SqfEntityFieldBase('profit', DbType.real),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProfitAndLoss();
  }
}

// User TABLE
class TableUser extends SqfEntityTableBase {
  TableUser() {
    // declare properties of EntityTable
    tableName = 'users';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('username', DbType.text),
      SqfEntityFieldBase('password', DbType.text),
      SqfEntityFieldBase('email', DbType.text),
      SqfEntityFieldBase('firstName', DbType.text),
      SqfEntityFieldBase('lastName', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUser();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class SalesSafeDbModel extends SqfEntityModelProvider {
  SalesSafeDbModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableCategory.getInstance,
      TableProduct.getInstance,
      TableLead.getInstance,
      TableSupplier.getInstance,
      TablePaymentMethod.getInstance,
      TablePaymentDetail.getInstance,
      TableOrder.getInstance,
      TableInvoice.getInstance,
      TablePayment.getInstance,
      TableSale.getInstance,
      TablePeriod.getInstance,
      TableExpense.getInstance,
      TableProfitAndLoss.getInstance,
      TableUser.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = myDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Category
class Category extends TableBase {
  Category({this.id, this.name, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Category.withFields(this.name, this.isDeleted) {
    _setDefaultValues();
  }
  Category.withId(this.id, this.name, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Category.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Category)
  int? id;
  String? name;
  bool? isDeleted;

  // end FIELDS (Category)

// COLLECTIONS & VIRTUALS (Category)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plProducts', 'plField2'..]) or so on..
  List<Product>? plProducts;

  /// get Product(s) filtered by id=categoryId
  ProductFilterBuilder? getProducts(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Product()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .categoryId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Category)

  static const bool _softDeleteActivated = true;
  CategoryManager? __mnCategory;

  CategoryManager get _mnCategory {
    return __mnCategory = __mnCategory ?? CategoryManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Category)
    if (!forQuery) {
      map['Products'] = await getProducts()!.toMapList();
    }
// END COLLECTIONS (Category)

    return map;
  }

  /// This method returns Json String [Category]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Category]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [name, isDeleted];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, isDeleted];
  }

  static Future<List<Category>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Category>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Category>[];
    try {
      objList = list
          .map((category) => Category.fromMap(category as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Category>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Category> objList = <Category>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Category.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('category.plProducts') && */ (preloadFields ==
                null ||
            preloadFields.contains('plProducts'))) {
          /*_loadedfields!.add('category.plProducts'); */ obj.plProducts =
              obj.plProducts ??
                  await obj.getProducts()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Category by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Category] if exist, otherwise returns null
  Future<Category?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Category? obj;
    final data = await _mnCategory.getById([id]);
    if (data.length != 0) {
      obj = Category.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('category.plProducts') && */ (preloadFields ==
                null ||
            preloadFields.contains('plProducts'))) {
          /*_loadedfields!.add('category.plProducts'); */ obj.plProducts =
              obj.plProducts ??
                  await obj.getProducts()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Category) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory.insert(this, ignoreBatch);
    } else {
      await _mnCategory.update(this);
    }

    return id;
  }

  /// Saves the (Category) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCategory.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Category. Returns a new Primary Key value of Category

  /// <returns>Returns a new Primary Key value of Category
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Category> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Category> categories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in categories) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < categories.length; i++) {
        if (categories[i].id == null) {
          categories[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCategory.rawInsert(
          'INSERT OR REPLACE INTO category (id, name,isDeleted)  VALUES (?,?,?)',
          [id, name, isDeleted],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Category id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Category id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Category Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Category>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Category> categories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCategory.rawInsertAll(
        'INSERT OR REPLACE INTO category (id, name,isDeleted)  VALUES (?,?,?)',
        categories,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Category

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Category invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Product()
          .select()
          .categoryId
          .equals(id)
          .and
          .update({'categoryId': null});
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnCategory
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCategory.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Category

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Category invoked (id=$id)');
    {
      return _mnCategory.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  CategoryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CategoryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion category

// region CategoryField
class CategoryField extends FilterBase {
  CategoryField(CategoryFilterBuilder categoryFB) : super(categoryFB);

  @override
  CategoryFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder isNull() {
    return super.isNull() as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CategoryFilterBuilder;
  }

  @override
  CategoryField get not {
    return super.not as CategoryField;
  }
}
// endregion CategoryField

// region CategoryFilterBuilder
class CategoryFilterBuilder extends ConjunctionBase {
  CategoryFilterBuilder(Category obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCategory = obj._mnCategory;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CategoryManager? _mnCategory;

  /// put the sql keyword 'AND'
  @override
  CategoryFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CategoryFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CategoryFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CategoryFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CategoryFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CategoryFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CategoryFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CategoryFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CategoryFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CategoryFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CategoryFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CategoryField _setField(CategoryField? field, String colName, DbType dbtype) {
    return CategoryField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CategoryField? _id;
  CategoryField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  CategoryField? _name;
  CategoryField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  CategoryField? _isDeleted;
  CategoryField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Category> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // UPDATE sub records where in (Product) according to DeleteRule.SET_NULL
    final idListProductBYcategoryId = toListPrimaryKeySQL(false);
    final resProductBYcategoryId = await Product()
        .select()
        .where('categoryId IN (${idListProductBYcategoryId['sql']})',
            parameterValue: idListProductBYcategoryId['args'])
        .update({'categoryId': null});
    if (!resProductBYcategoryId.success) {
      return resProductBYcategoryId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCategory!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCategory!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Category> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Category bulk invoked');
    return _mnCategory!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from category ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCategory!.updateBatch(qparams, values);
  }

  /// This method always returns [Category] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Category?
  @override
  Future<Category?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCategory!.toList(qparams);
    final data = await objFuture;
    Category? obj;
    if (data.isNotEmpty) {
      obj = Category.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('category.plProducts') && */ (preloadFields ==
                null ||
            preloadFields.contains('plProducts'))) {
          /*_loadedfields!.add('category.plProducts'); */ obj.plProducts =
              obj.plProducts ??
                  await obj.getProducts()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Category]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Category?
  @override
  Future<Category> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Category();
  }

  /// This method returns int. [Category]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? categoryCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final categoriesFuture = await _mnCategory!.toList(qparams);
    final int count = categoriesFuture[0]['CNT'] as int;
    if (categoryCount != null) {
      categoryCount(count);
    }
    return count;
  }

  /// This method returns List<Category> [Category]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Category>
  @override
  Future<List<Category>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Category> categoriesData = await Category.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return categoriesData;
  }

  /// This method returns Json String [Category]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Category]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Category]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCategory!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Category]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM category WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCategory!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Category]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCategory!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Category.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCategory!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CategoryFilterBuilder

// region CategoryFields
class CategoryFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion CategoryFields

//region CategoryManager
class CategoryManager extends SqfEntityProvider {
  CategoryManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'category';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CategoryManager
// region Product
class Product extends TableBase {
  Product(
      {this.id,
      this.name,
      this.description,
      this.cost,
      this.price,
      this.quantity,
      this.categoryId,
      this.reference,
      this.image_url,
      this.expiry_date,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Product.withFields(
      this.name,
      this.description,
      this.cost,
      this.price,
      this.quantity,
      this.categoryId,
      this.reference,
      this.image_url,
      this.expiry_date,
      this.date,
      this.isDeleted) {
    _setDefaultValues();
  }
  Product.withId(
      this.id,
      this.name,
      this.description,
      this.cost,
      this.price,
      this.quantity,
      this.categoryId,
      this.reference,
      this.image_url,
      this.expiry_date,
      this.date,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Product.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['cost'] != null) {
      cost = double.tryParse(o['cost'].toString());
    }
    if (o['price'] != null) {
      price = double.tryParse(o['price'].toString());
    }
    if (o['quantity'] != null) {
      quantity = int.tryParse(o['quantity'].toString());
    }
    categoryId = int.tryParse(o['categoryId'].toString());

    if (o['reference'] != null) {
      reference = int.tryParse(o['reference'].toString());
    }
    if (o['image_url'] != null) {
      image_url = o['image_url'].toString();
    }
    if (o['expiry_date'] != null) {
      expiry_date = int.tryParse(o['expiry_date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['expiry_date'].toString())!)
          : DateTime.tryParse(o['expiry_date'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plCategory = o['category'] != null
        ? Category.fromMap(o['category'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Product)
  int? id;
  String? name;
  String? description;
  double? cost;
  double? price;
  int? quantity;
  int? categoryId;
  int? reference;
  String? image_url;
  DateTime? expiry_date;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Product)

// RELATIONSHIPS (Product)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCategory', 'plField2'..]) or so on..
  Category? plCategory;

  /// get Category By CategoryId
  Future<Category?> getCategory(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Category().getById(categoryId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Product)

// COLLECTIONS & VIRTUALS (Product)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plOrders', 'plField2'..]) or so on..
  List<Order>? plOrders;

  /// get Order(s) filtered by id=productId
  OrderFilterBuilder? getOrders(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Order()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .productId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Product)

  static const bool _softDeleteActivated = true;
  ProductManager? __mnProduct;

  ProductManager get _mnProduct {
    return __mnProduct = __mnProduct ?? ProductManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (cost != null || !forView) {
      map['cost'] = cost;
    }
    if (price != null || !forView) {
      map['price'] = price;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (categoryId != null) {
      map['categoryId'] = forView
          ? plCategory == null
              ? categoryId
              : plCategory!.name
          : categoryId;
    } else if (categoryId != null || !forView) {
      map['categoryId'] = null;
    }
    if (reference != null || !forView) {
      map['reference'] = reference;
    }
    if (image_url != null || !forView) {
      map['image_url'] = image_url;
    }
    if (expiry_date != null) {
      map['expiry_date'] = forJson
          ? expiry_date!.toString()
          : forQuery
              ? expiry_date!.millisecondsSinceEpoch
              : expiry_date;
    } else if (expiry_date != null || !forView) {
      map['expiry_date'] = null;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (cost != null || !forView) {
      map['cost'] = cost;
    }
    if (price != null || !forView) {
      map['price'] = price;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (categoryId != null) {
      map['categoryId'] = forView
          ? plCategory == null
              ? categoryId
              : plCategory!.name
          : categoryId;
    } else if (categoryId != null || !forView) {
      map['categoryId'] = null;
    }
    if (reference != null || !forView) {
      map['reference'] = reference;
    }
    if (image_url != null || !forView) {
      map['image_url'] = image_url;
    }
    if (expiry_date != null) {
      map['expiry_date'] = forJson
          ? expiry_date!.toString()
          : forQuery
              ? expiry_date!.millisecondsSinceEpoch
              : expiry_date;
    } else if (expiry_date != null || !forView) {
      map['expiry_date'] = null;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Product)
    if (!forQuery) {
      map['Orders'] = await getOrders()!.toMapList();
    }
// END COLLECTIONS (Product)

    return map;
  }

  /// This method returns Json String [Product]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Product]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      description,
      cost,
      price,
      quantity,
      categoryId,
      reference,
      image_url,
      expiry_date != null ? expiry_date!.millisecondsSinceEpoch : null,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      description,
      cost,
      price,
      quantity,
      categoryId,
      reference,
      image_url,
      expiry_date != null ? expiry_date!.millisecondsSinceEpoch : null,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Product>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Product.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Product>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Product>[];
    try {
      objList = list
          .map((product) => Product.fromMap(product as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Product.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Product>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Product> objList = <Product>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Product.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('product.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('product.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCategory'))) {
          obj.plCategory =
              obj.plCategory ?? await obj.getCategory(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Product by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Product] if exist, otherwise returns null
  Future<Product?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Product? obj;
    final data = await _mnProduct.getById([id]);
    if (data.length != 0) {
      obj = Product.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('product.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('product.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCategory'))) {
          obj.plCategory =
              obj.plCategory ?? await obj.getCategory(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Product) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      reference = await IdentitySequence().nextVal();

      id = await _mnProduct.insert(this, ignoreBatch);
    } else {
      await _mnProduct.update(this);
    }

    return id;
  }

  /// Saves the (Product) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      reference = await IdentitySequence().nextVal();

      id = await _mnProduct.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProduct.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Product. Returns a new Primary Key value of Product

  /// <returns>Returns a new Primary Key value of Product
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Product> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Product> products,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in products) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < products.length; i++) {
        if (products[i].id == null) {
          products[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProduct.rawInsert(
          'INSERT OR REPLACE INTO product (id, name, description, cost, price, quantity, categoryId, reference, image_url, expiry_date, date,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            description,
            cost,
            price,
            quantity,
            categoryId,
            reference,
            image_url,
            expiry_date != null ? expiry_date!.millisecondsSinceEpoch : null,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Product id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Product id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Product Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Product>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Product> products,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnProduct.rawInsertAll(
        'INSERT OR REPLACE INTO product (id, name, description, cost, price, quantity, categoryId, reference, image_url, expiry_date, date,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        products,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Product

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Product invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await Order().select().productId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnProduct
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProduct.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Product

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Product invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await Order()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .productId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnProduct.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ProductFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProductFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    categoryId = categoryId ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion product

// region ProductField
class ProductField extends FilterBase {
  ProductField(ProductFilterBuilder productFB) : super(productFB);

  @override
  ProductFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder isNull() {
    return super.isNull() as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProductFilterBuilder;
  }

  @override
  ProductFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProductFilterBuilder;
  }

  @override
  ProductField get not {
    return super.not as ProductField;
  }
}
// endregion ProductField

// region ProductFilterBuilder
class ProductFilterBuilder extends ConjunctionBase {
  ProductFilterBuilder(Product obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProduct = obj._mnProduct;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProductManager? _mnProduct;

  /// put the sql keyword 'AND'
  @override
  ProductFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProductFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProductFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProductFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProductFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProductFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProductFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProductField _setField(ProductField? field, String colName, DbType dbtype) {
    return ProductField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProductField? _id;
  ProductField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ProductField? _name;
  ProductField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  ProductField? _description;
  ProductField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  ProductField? _cost;
  ProductField get cost {
    return _cost = _setField(_cost, 'cost', DbType.real);
  }

  ProductField? _price;
  ProductField get price {
    return _price = _setField(_price, 'price', DbType.real);
  }

  ProductField? _quantity;
  ProductField get quantity {
    return _quantity = _setField(_quantity, 'quantity', DbType.integer);
  }

  ProductField? _categoryId;
  ProductField get categoryId {
    return _categoryId = _setField(_categoryId, 'categoryId', DbType.integer);
  }

  ProductField? _reference;
  ProductField get reference {
    return _reference = _setField(_reference, 'reference', DbType.integer);
  }

  ProductField? _image_url;
  ProductField get image_url {
    return _image_url = _setField(_image_url, 'image_url', DbType.text);
  }

  ProductField? _expiry_date;
  ProductField get expiry_date {
    return _expiry_date =
        _setField(_expiry_date, 'expiry_date', DbType.datetime);
  }

  ProductField? _date;
  ProductField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  ProductField? _isDeleted;
  ProductField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Product> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Order) according to DeleteRule.CASCADE
    final idListOrderBYproductId = toListPrimaryKeySQL(false);
    final resOrderBYproductId = await Order()
        .select()
        .where('productId IN (${idListOrderBYproductId['sql']})',
            parameterValue: idListOrderBYproductId['args'])
        .delete(hardDelete);
    if (!resOrderBYproductId.success) {
      return resOrderBYproductId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProduct!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProduct!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Product> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Product bulk invoked');
    // Recover sub records where in (Order) according to DeleteRule.CASCADE
    final idListOrderBYproductId = toListPrimaryKeySQL(false);
    final resOrderBYproductId = await Order()
        .select()
        .where('productId IN (${idListOrderBYproductId['sql']})',
            parameterValue: idListOrderBYproductId['args'])
        .update({'isDeleted': 0});
    if (!resOrderBYproductId.success) {
      return resOrderBYproductId;
    }
    return _mnProduct!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from product ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProduct!.updateBatch(qparams, values);
  }

  /// This method always returns [Product] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Product?
  @override
  Future<Product?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProduct!.toList(qparams);
    final data = await objFuture;
    Product? obj;
    if (data.isNotEmpty) {
      obj = Product.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('product.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('product.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCategory'))) {
          obj.plCategory =
              obj.plCategory ?? await obj.getCategory(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Product]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Product?
  @override
  Future<Product> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Product();
  }

  /// This method returns int. [Product]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? productCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productsFuture = await _mnProduct!.toList(qparams);
    final int count = productsFuture[0]['CNT'] as int;
    if (productCount != null) {
      productCount(count);
    }
    return count;
  }

  /// This method returns List<Product> [Product]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Product>
  @override
  Future<List<Product>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Product> productsData = await Product.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return productsData;
  }

  /// This method returns Json String [Product]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Product]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Product]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProduct!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Product]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM product WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnProduct!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Product]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProduct!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Product.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProduct!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductFilterBuilder

// region ProductFields
class ProductFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fCost;
  static TableField get cost {
    return _fCost = _fCost ?? SqlSyntax.setField(_fCost, 'cost', DbType.real);
  }

  static TableField? _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.real);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'quantity', DbType.integer);
  }

  static TableField? _fCategoryId;
  static TableField get categoryId {
    return _fCategoryId = _fCategoryId ??
        SqlSyntax.setField(_fCategoryId, 'categoryId', DbType.integer);
  }

  static TableField? _fReference;
  static TableField get reference {
    return _fReference = _fReference ??
        SqlSyntax.setField(_fReference, 'reference', DbType.integer);
  }

  static TableField? _fImage_url;
  static TableField get image_url {
    return _fImage_url = _fImage_url ??
        SqlSyntax.setField(_fImage_url, 'image_url', DbType.text);
  }

  static TableField? _fExpiry_date;
  static TableField get expiry_date {
    return _fExpiry_date = _fExpiry_date ??
        SqlSyntax.setField(_fExpiry_date, 'expiry_date', DbType.datetime);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ProductFields

//region ProductManager
class ProductManager extends SqfEntityProvider {
  ProductManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'product';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProductManager
// region Lead
class Lead extends TableBase {
  Lead(
      {this.id, this.name, this.email, this.phone, this.date, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Lead.withFields(
      this.name, this.email, this.phone, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  Lead.withId(
      this.id, this.name, this.email, this.phone, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Lead.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['email'] != null) {
      email = o['email'].toString();
    }
    if (o['phone'] != null) {
      phone = o['phone'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Lead)
  int? id;
  String? name;
  String? email;
  String? phone;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Lead)

  static const bool _softDeleteActivated = true;
  LeadManager? __mnLead;

  LeadManager get _mnLead {
    return __mnLead = __mnLead ?? LeadManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (phone != null || !forView) {
      map['phone'] = phone;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (phone != null || !forView) {
      map['phone'] = phone;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Lead]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Lead]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      email,
      phone,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      email,
      phone,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Lead>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Lead.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Lead>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Lead>[];
    try {
      objList = list
          .map((lead) => Lead.fromMap(lead as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Lead.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Lead>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Lead> objList = <Lead>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Lead.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Lead by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Lead] if exist, otherwise returns null
  Future<Lead?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Lead? obj;
    final data = await _mnLead.getById([id]);
    if (data.length != 0) {
      obj = Lead.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Lead) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLead.insert(this, ignoreBatch);
    } else {
      await _mnLead.update(this);
    }

    return id;
  }

  /// Saves the (Lead) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLead.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnLead.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Lead. Returns a new Primary Key value of Lead

  /// <returns>Returns a new Primary Key value of Lead
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Lead> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Lead> leads,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in leads) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < leads.length; i++) {
        if (leads[i].id == null) {
          leads[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLead.rawInsert(
          'INSERT OR REPLACE INTO lead (id, name, email, phone, date,isDeleted)  VALUES (?,?,?,?,?,?)',
          [
            id,
            name,
            email,
            phone,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Lead id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Lead id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Lead Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Lead>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Lead> leads,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnLead.rawInsertAll(
        'INSERT OR REPLACE INTO lead (id, name, email, phone, date,isDeleted)  VALUES (?,?,?,?,?,?)',
        leads,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Lead

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Lead invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnLead
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnLead.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Lead

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Lead invoked (id=$id)');
    {
      return _mnLead.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  LeadFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LeadFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LeadFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LeadFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion lead

// region LeadField
class LeadField extends FilterBase {
  LeadField(LeadFilterBuilder leadFB) : super(leadFB);

  @override
  LeadFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder isNull() {
    return super.isNull() as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LeadFilterBuilder;
  }

  @override
  LeadFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LeadFilterBuilder;
  }

  @override
  LeadField get not {
    return super.not as LeadField;
  }
}
// endregion LeadField

// region LeadFilterBuilder
class LeadFilterBuilder extends ConjunctionBase {
  LeadFilterBuilder(Lead obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnLead = obj._mnLead;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LeadManager? _mnLead;

  /// put the sql keyword 'AND'
  @override
  LeadFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LeadFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LeadFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LeadFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LeadFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LeadFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LeadFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LeadFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LeadFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LeadFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LeadFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LeadField _setField(LeadField? field, String colName, DbType dbtype) {
    return LeadField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LeadField? _id;
  LeadField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  LeadField? _name;
  LeadField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  LeadField? _email;
  LeadField get email {
    return _email = _setField(_email, 'email', DbType.text);
  }

  LeadField? _phone;
  LeadField get phone {
    return _phone = _setField(_phone, 'phone', DbType.text);
  }

  LeadField? _date;
  LeadField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  LeadField? _isDeleted;
  LeadField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Lead> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLead!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLead!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Lead> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Lead bulk invoked');
    return _mnLead!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from lead ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLead!.updateBatch(qparams, values);
  }

  /// This method always returns [Lead] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Lead?
  @override
  Future<Lead?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLead!.toList(qparams);
    final data = await objFuture;
    Lead? obj;
    if (data.isNotEmpty) {
      obj = Lead.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Lead]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Lead?
  @override
  Future<Lead> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Lead();
  }

  /// This method returns int. [Lead]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? leadCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final leadsFuture = await _mnLead!.toList(qparams);
    final int count = leadsFuture[0]['CNT'] as int;
    if (leadCount != null) {
      leadCount(count);
    }
    return count;
  }

  /// This method returns List<Lead> [Lead]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Lead>
  @override
  Future<List<Lead>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Lead> leadsData = await Lead.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return leadsData;
  }

  /// This method returns Json String [Lead]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Lead]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Lead]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLead!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Lead]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM lead WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnLead!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Lead]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLead!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Lead.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLead!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LeadFilterBuilder

// region LeadFields
class LeadFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'email', DbType.text);
  }

  static TableField? _fPhone;
  static TableField get phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'phone', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion LeadFields

//region LeadManager
class LeadManager extends SqfEntityProvider {
  LeadManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'lead';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion LeadManager
// region Supplier
class Supplier extends TableBase {
  Supplier(
      {this.id,
      this.name,
      this.email,
      this.phone,
      this.description,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Supplier.withFields(this.name, this.email, this.phone, this.description,
      this.date, this.isDeleted) {
    _setDefaultValues();
  }
  Supplier.withId(this.id, this.name, this.email, this.phone, this.description,
      this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Supplier.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['email'] != null) {
      email = o['email'].toString();
    }
    if (o['phone'] != null) {
      phone = o['phone'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Supplier)
  int? id;
  String? name;
  String? email;
  String? phone;
  String? description;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Supplier)

  static const bool _softDeleteActivated = true;
  SupplierManager? __mnSupplier;

  SupplierManager get _mnSupplier {
    return __mnSupplier = __mnSupplier ?? SupplierManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (phone != null || !forView) {
      map['phone'] = phone;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (phone != null || !forView) {
      map['phone'] = phone;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Supplier]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Supplier]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      email,
      phone,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      email,
      phone,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Supplier>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Supplier.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Supplier>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Supplier>[];
    try {
      objList = list
          .map((supplier) => Supplier.fromMap(supplier as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Supplier.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Supplier>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Supplier> objList = <Supplier>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Supplier.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Supplier by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Supplier] if exist, otherwise returns null
  Future<Supplier?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Supplier? obj;
    final data = await _mnSupplier.getById([id]);
    if (data.length != 0) {
      obj = Supplier.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Supplier) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSupplier.insert(this, ignoreBatch);
    } else {
      await _mnSupplier.update(this);
    }

    return id;
  }

  /// Saves the (Supplier) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSupplier.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSupplier.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Supplier. Returns a new Primary Key value of Supplier

  /// <returns>Returns a new Primary Key value of Supplier
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Supplier> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Supplier> suppliers,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in suppliers) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < suppliers.length; i++) {
        if (suppliers[i].id == null) {
          suppliers[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSupplier.rawInsert(
          'INSERT OR REPLACE INTO supplier (id, name, email, phone, description, date,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            name,
            email,
            phone,
            description,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Supplier id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Supplier id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Supplier Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Supplier>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Supplier> suppliers,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSupplier.rawInsertAll(
        'INSERT OR REPLACE INTO supplier (id, name, email, phone, description, date,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        suppliers,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Supplier

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Supplier invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnSupplier
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSupplier.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Supplier

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Supplier invoked (id=$id)');
    {
      return _mnSupplier.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  SupplierFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SupplierFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SupplierFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SupplierFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion supplier

// region SupplierField
class SupplierField extends FilterBase {
  SupplierField(SupplierFilterBuilder supplierFB) : super(supplierFB);

  @override
  SupplierFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder isNull() {
    return super.isNull() as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SupplierFilterBuilder;
  }

  @override
  SupplierField get not {
    return super.not as SupplierField;
  }
}
// endregion SupplierField

// region SupplierFilterBuilder
class SupplierFilterBuilder extends ConjunctionBase {
  SupplierFilterBuilder(Supplier obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSupplier = obj._mnSupplier;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SupplierManager? _mnSupplier;

  /// put the sql keyword 'AND'
  @override
  SupplierFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SupplierFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SupplierFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SupplierFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SupplierFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SupplierFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SupplierFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SupplierFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SupplierFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SupplierFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SupplierFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SupplierField _setField(SupplierField? field, String colName, DbType dbtype) {
    return SupplierField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SupplierField? _id;
  SupplierField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SupplierField? _name;
  SupplierField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  SupplierField? _email;
  SupplierField get email {
    return _email = _setField(_email, 'email', DbType.text);
  }

  SupplierField? _phone;
  SupplierField get phone {
    return _phone = _setField(_phone, 'phone', DbType.text);
  }

  SupplierField? _description;
  SupplierField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  SupplierField? _date;
  SupplierField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  SupplierField? _isDeleted;
  SupplierField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Supplier> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSupplier!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSupplier!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Supplier> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Supplier bulk invoked');
    return _mnSupplier!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from supplier ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSupplier!.updateBatch(qparams, values);
  }

  /// This method always returns [Supplier] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Supplier?
  @override
  Future<Supplier?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSupplier!.toList(qparams);
    final data = await objFuture;
    Supplier? obj;
    if (data.isNotEmpty) {
      obj = Supplier.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Supplier]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Supplier?
  @override
  Future<Supplier> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Supplier();
  }

  /// This method returns int. [Supplier]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? supplierCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final suppliersFuture = await _mnSupplier!.toList(qparams);
    final int count = suppliersFuture[0]['CNT'] as int;
    if (supplierCount != null) {
      supplierCount(count);
    }
    return count;
  }

  /// This method returns List<Supplier> [Supplier]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Supplier>
  @override
  Future<List<Supplier>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Supplier> suppliersData = await Supplier.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return suppliersData;
  }

  /// This method returns Json String [Supplier]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Supplier]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Supplier]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSupplier!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Supplier]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM supplier WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSupplier!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Supplier]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSupplier!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Supplier.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSupplier!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SupplierFilterBuilder

// region SupplierFields
class SupplierFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'email', DbType.text);
  }

  static TableField? _fPhone;
  static TableField get phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'phone', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion SupplierFields

//region SupplierManager
class SupplierManager extends SqfEntityProvider {
  SupplierManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'supplier';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SupplierManager
// region PaymentMethod
class PaymentMethod extends TableBase {
  PaymentMethod(
      {this.id, this.name, this.description, this.date, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  PaymentMethod.withFields(
      this.name, this.description, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  PaymentMethod.withId(
      this.id, this.name, this.description, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PaymentMethod.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (PaymentMethod)
  int? id;
  String? name;
  String? description;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (PaymentMethod)

// COLLECTIONS & VIRTUALS (PaymentMethod)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPaymentDetails', 'plField2'..]) or so on..
  List<PaymentDetail>? plPaymentDetails;

  /// get PaymentDetail(s) filtered by id=paymentMethodsId
  PaymentDetailFilterBuilder? getPaymentDetails(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PaymentDetail()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .paymentMethodsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPayments', 'plField2'..]) or so on..
  List<Payment>? plPayments;

  /// get Payment(s) filtered by id=paymentMethodsId
  PaymentFilterBuilder? getPayments(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Payment()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .paymentMethodsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (PaymentMethod)

  static const bool _softDeleteActivated = true;
  PaymentMethodManager? __mnPaymentMethod;

  PaymentMethodManager get _mnPaymentMethod {
    return __mnPaymentMethod = __mnPaymentMethod ?? PaymentMethodManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (PaymentMethod)
    if (!forQuery) {
      map['PaymentDetails'] = await getPaymentDetails()!.toMapList();
    }
    if (!forQuery) {
      map['Payments'] = await getPayments()!.toMapList();
    }
// END COLLECTIONS (PaymentMethod)

    return map;
  }

  /// This method returns Json String [PaymentMethod]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PaymentMethod]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<PaymentMethod>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaymentMethod.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PaymentMethod>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PaymentMethod>[];
    try {
      objList = list
          .map((paymentmethod) =>
              PaymentMethod.fromMap(paymentmethod as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaymentMethod.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PaymentMethod>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PaymentMethod> objList = <PaymentMethod>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PaymentMethod.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('paymentMethods.plPaymentDetails') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPaymentDetails'))) {
          /*_loadedfields!.add('paymentMethods.plPaymentDetails'); */ obj
                  .plPaymentDetails =
              obj.plPaymentDetails ??
                  await obj.getPaymentDetails()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('paymentMethods.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('paymentMethods.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PaymentMethod by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PaymentMethod] if exist, otherwise returns null
  Future<PaymentMethod?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    PaymentMethod? obj;
    final data = await _mnPaymentMethod.getById([id]);
    if (data.length != 0) {
      obj = PaymentMethod.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('paymentMethods.plPaymentDetails') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPaymentDetails'))) {
          /*_loadedfields!.add('paymentMethods.plPaymentDetails'); */ obj
                  .plPaymentDetails =
              obj.plPaymentDetails ??
                  await obj.getPaymentDetails()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('paymentMethods.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('paymentMethods.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PaymentMethod) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPaymentMethod.insert(this, ignoreBatch);
    } else {
      await _mnPaymentMethod.update(this);
    }

    return id;
  }

  /// Saves the (PaymentMethod) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPaymentMethod.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPaymentMethod.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs PaymentMethod. Returns a new Primary Key value of PaymentMethod

  /// <returns>Returns a new Primary Key value of PaymentMethod
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<PaymentMethod> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<PaymentMethod> paymentmethods,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in paymentmethods) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < paymentmethods.length; i++) {
        if (paymentmethods[i].id == null) {
          paymentmethods[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPaymentMethod.rawInsert(
          'INSERT OR REPLACE INTO paymentMethods (id, name, description, date,isDeleted)  VALUES (?,?,?,?,?)',
          [
            id,
            name,
            description,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PaymentMethod id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PaymentMethod id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PaymentMethod Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PaymentMethod>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<PaymentMethod> paymentmethods,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPaymentMethod.rawInsertAll(
        'INSERT OR REPLACE INTO paymentMethods (id, name, description, date,isDeleted)  VALUES (?,?,?,?,?)',
        paymentmethods,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes PaymentMethod

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PaymentMethod invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await PaymentDetail()
          .select()
          .paymentMethodsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await Payment()
          .select()
          .paymentMethodsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnPaymentMethod
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPaymentMethod.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover PaymentMethod

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover PaymentMethod invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await PaymentDetail()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .paymentMethodsId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await Payment()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .paymentMethodsId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnPaymentMethod.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  PaymentMethodFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentMethodFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PaymentMethodFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentMethodFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion paymentmethod

// region PaymentMethodField
class PaymentMethodField extends FilterBase {
  PaymentMethodField(PaymentMethodFilterBuilder paymentmethodFB)
      : super(paymentmethodFB);

  @override
  PaymentMethodFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder isNull() {
    return super.isNull() as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PaymentMethodFilterBuilder;
  }

  @override
  PaymentMethodField get not {
    return super.not as PaymentMethodField;
  }
}
// endregion PaymentMethodField

// region PaymentMethodFilterBuilder
class PaymentMethodFilterBuilder extends ConjunctionBase {
  PaymentMethodFilterBuilder(PaymentMethod obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPaymentMethod = obj._mnPaymentMethod;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PaymentMethodManager? _mnPaymentMethod;

  /// put the sql keyword 'AND'
  @override
  PaymentMethodFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PaymentMethodFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PaymentMethodFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PaymentMethodFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PaymentMethodFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PaymentMethodFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PaymentMethodFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentMethodFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentMethodFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentMethodFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentMethodFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PaymentMethodField _setField(
      PaymentMethodField? field, String colName, DbType dbtype) {
    return PaymentMethodField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PaymentMethodField? _id;
  PaymentMethodField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PaymentMethodField? _name;
  PaymentMethodField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  PaymentMethodField? _description;
  PaymentMethodField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  PaymentMethodField? _date;
  PaymentMethodField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  PaymentMethodField? _isDeleted;
  PaymentMethodField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<PaymentMethod> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (PaymentDetail) according to DeleteRule.CASCADE
    final idListPaymentDetailBYpaymentMethodsId = toListPrimaryKeySQL(false);
    final resPaymentDetailBYpaymentMethodsId = await PaymentDetail()
        .select()
        .where(
            'paymentMethodsId IN (${idListPaymentDetailBYpaymentMethodsId['sql']})',
            parameterValue: idListPaymentDetailBYpaymentMethodsId['args'])
        .delete(hardDelete);
    if (!resPaymentDetailBYpaymentMethodsId.success) {
      return resPaymentDetailBYpaymentMethodsId;
    }
// Delete sub records where in (Payment) according to DeleteRule.CASCADE
    final idListPaymentBYpaymentMethodsId = toListPrimaryKeySQL(false);
    final resPaymentBYpaymentMethodsId = await Payment()
        .select()
        .where(
            'paymentMethodsId IN (${idListPaymentBYpaymentMethodsId['sql']})',
            parameterValue: idListPaymentBYpaymentMethodsId['args'])
        .delete(hardDelete);
    if (!resPaymentBYpaymentMethodsId.success) {
      return resPaymentBYpaymentMethodsId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPaymentMethod!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPaymentMethod!.delete(qparams);
    }
    return r;
  }

  /// Recover List<PaymentMethod> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover PaymentMethod bulk invoked');
    // Recover sub records where in (PaymentDetail) according to DeleteRule.CASCADE
    final idListPaymentDetailBYpaymentMethodsId = toListPrimaryKeySQL(false);
    final resPaymentDetailBYpaymentMethodsId = await PaymentDetail()
        .select()
        .where(
            'paymentMethodsId IN (${idListPaymentDetailBYpaymentMethodsId['sql']})',
            parameterValue: idListPaymentDetailBYpaymentMethodsId['args'])
        .update({'isDeleted': 0});
    if (!resPaymentDetailBYpaymentMethodsId.success) {
      return resPaymentDetailBYpaymentMethodsId;
    }
// Recover sub records where in (Payment) according to DeleteRule.CASCADE
    final idListPaymentBYpaymentMethodsId = toListPrimaryKeySQL(false);
    final resPaymentBYpaymentMethodsId = await Payment()
        .select()
        .where(
            'paymentMethodsId IN (${idListPaymentBYpaymentMethodsId['sql']})',
            parameterValue: idListPaymentBYpaymentMethodsId['args'])
        .update({'isDeleted': 0});
    if (!resPaymentBYpaymentMethodsId.success) {
      return resPaymentBYpaymentMethodsId;
    }
    return _mnPaymentMethod!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from paymentMethods ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPaymentMethod!.updateBatch(qparams, values);
  }

  /// This method always returns [PaymentMethod] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaymentMethod?
  @override
  Future<PaymentMethod?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPaymentMethod!.toList(qparams);
    final data = await objFuture;
    PaymentMethod? obj;
    if (data.isNotEmpty) {
      obj = PaymentMethod.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('paymentMethods.plPaymentDetails') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPaymentDetails'))) {
          /*_loadedfields!.add('paymentMethods.plPaymentDetails'); */ obj
                  .plPaymentDetails =
              obj.plPaymentDetails ??
                  await obj.getPaymentDetails()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('paymentMethods.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('paymentMethods.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PaymentMethod]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaymentMethod?
  @override
  Future<PaymentMethod> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PaymentMethod();
  }

  /// This method returns int. [PaymentMethod]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? paymentmethodCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final paymentmethodsFuture = await _mnPaymentMethod!.toList(qparams);
    final int count = paymentmethodsFuture[0]['CNT'] as int;
    if (paymentmethodCount != null) {
      paymentmethodCount(count);
    }
    return count;
  }

  /// This method returns List<PaymentMethod> [PaymentMethod]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PaymentMethod>
  @override
  Future<List<PaymentMethod>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PaymentMethod> paymentmethodsData =
        await PaymentMethod.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return paymentmethodsData;
  }

  /// This method returns Json String [PaymentMethod]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PaymentMethod]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PaymentMethod]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPaymentMethod!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PaymentMethod]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM paymentMethods WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPaymentMethod!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PaymentMethod]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPaymentMethod!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PaymentMethod.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPaymentMethod!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaymentMethodFilterBuilder

// region PaymentMethodFields
class PaymentMethodFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion PaymentMethodFields

//region PaymentMethodManager
class PaymentMethodManager extends SqfEntityProvider {
  PaymentMethodManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'paymentMethods';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PaymentMethodManager
// region PaymentDetail
class PaymentDetail extends TableBase {
  PaymentDetail(
      {this.id,
      this.paymentMethodsId,
      this.details,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  PaymentDetail.withFields(
      this.paymentMethodsId, this.details, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  PaymentDetail.withId(
      this.id, this.paymentMethodsId, this.details, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PaymentDetail.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    paymentMethodsId = int.tryParse(o['paymentMethodsId'].toString());

    if (o['details'] != null) {
      details = o['details'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plPaymentMethod = o['paymentMethod'] != null
        ? PaymentMethod.fromMap(o['paymentMethod'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (PaymentDetail)
  int? id;
  int? paymentMethodsId;
  String? details;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (PaymentDetail)

// RELATIONSHIPS (PaymentDetail)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPaymentMethod', 'plField2'..]) or so on..
  PaymentMethod? plPaymentMethod;

  /// get PaymentMethod By PaymentMethodsId
  Future<PaymentMethod?> getPaymentMethod(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await PaymentMethod().getById(paymentMethodsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PaymentDetail)

  static const bool _softDeleteActivated = true;
  PaymentDetailManager? __mnPaymentDetail;

  PaymentDetailManager get _mnPaymentDetail {
    return __mnPaymentDetail = __mnPaymentDetail ?? PaymentDetailManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (paymentMethodsId != null) {
      map['paymentMethodsId'] = forView
          ? plPaymentMethod == null
              ? paymentMethodsId
              : plPaymentMethod!.name
          : paymentMethodsId;
    } else if (paymentMethodsId != null || !forView) {
      map['paymentMethodsId'] = null;
    }
    if (details != null || !forView) {
      map['details'] = details;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (paymentMethodsId != null) {
      map['paymentMethodsId'] = forView
          ? plPaymentMethod == null
              ? paymentMethodsId
              : plPaymentMethod!.name
          : paymentMethodsId;
    } else if (paymentMethodsId != null || !forView) {
      map['paymentMethodsId'] = null;
    }
    if (details != null || !forView) {
      map['details'] = details;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date!.year-$date!.month-$date!.day'
          : forQuery
              ? DateTime(date!.year, date!.month, date!.day)
                  .millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [PaymentDetail]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PaymentDetail]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      paymentMethodsId,
      details,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      paymentMethodsId,
      details,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<PaymentDetail>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaymentDetail.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PaymentDetail>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PaymentDetail>[];
    try {
      objList = list
          .map((paymentdetail) =>
              PaymentDetail.fromMap(paymentdetail as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaymentDetail.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PaymentDetail>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PaymentDetail> objList = <PaymentDetail>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PaymentDetail.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PaymentDetail by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PaymentDetail] if exist, otherwise returns null
  Future<PaymentDetail?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    PaymentDetail? obj;
    final data = await _mnPaymentDetail.getById([id]);
    if (data.length != 0) {
      obj = PaymentDetail.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PaymentDetail) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPaymentDetail.insert(this, ignoreBatch);
    } else {
      await _mnPaymentDetail.update(this);
    }

    return id;
  }

  /// Saves the (PaymentDetail) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPaymentDetail.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPaymentDetail.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs PaymentDetail. Returns a new Primary Key value of PaymentDetail

  /// <returns>Returns a new Primary Key value of PaymentDetail
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<PaymentDetail> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<PaymentDetail> paymentdetails,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in paymentdetails) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < paymentdetails.length; i++) {
        if (paymentdetails[i].id == null) {
          paymentdetails[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPaymentDetail.rawInsert(
          'INSERT OR REPLACE INTO paymentDetails (id, paymentMethodsId, details, date,isDeleted)  VALUES (?,?,?,?,?)',
          [
            id,
            paymentMethodsId,
            details,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PaymentDetail id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PaymentDetail id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PaymentDetail Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PaymentDetail>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<PaymentDetail> paymentdetails,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPaymentDetail.rawInsertAll(
        'INSERT OR REPLACE INTO paymentDetails (id, paymentMethodsId, details, date,isDeleted)  VALUES (?,?,?,?,?)',
        paymentdetails,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes PaymentDetail

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PaymentDetail invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnPaymentDetail
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPaymentDetail.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover PaymentDetail

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover PaymentDetail invoked (id=$id)');
    {
      return _mnPaymentDetail.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  PaymentDetailFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentDetailFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PaymentDetailFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentDetailFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    paymentMethodsId = paymentMethodsId ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion paymentdetail

// region PaymentDetailField
class PaymentDetailField extends FilterBase {
  PaymentDetailField(PaymentDetailFilterBuilder paymentdetailFB)
      : super(paymentdetailFB);

  @override
  PaymentDetailFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder isNull() {
    return super.isNull() as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PaymentDetailFilterBuilder;
  }

  @override
  PaymentDetailField get not {
    return super.not as PaymentDetailField;
  }
}
// endregion PaymentDetailField

// region PaymentDetailFilterBuilder
class PaymentDetailFilterBuilder extends ConjunctionBase {
  PaymentDetailFilterBuilder(PaymentDetail obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPaymentDetail = obj._mnPaymentDetail;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PaymentDetailManager? _mnPaymentDetail;

  /// put the sql keyword 'AND'
  @override
  PaymentDetailFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PaymentDetailFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PaymentDetailFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PaymentDetailFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PaymentDetailFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PaymentDetailFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PaymentDetailFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentDetailFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentDetailFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentDetailFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentDetailFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PaymentDetailField _setField(
      PaymentDetailField? field, String colName, DbType dbtype) {
    return PaymentDetailField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PaymentDetailField? _id;
  PaymentDetailField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PaymentDetailField? _paymentMethodsId;
  PaymentDetailField get paymentMethodsId {
    return _paymentMethodsId =
        _setField(_paymentMethodsId, 'paymentMethodsId', DbType.integer);
  }

  PaymentDetailField? _details;
  PaymentDetailField get details {
    return _details = _setField(_details, 'details', DbType.text);
  }

  PaymentDetailField? _date;
  PaymentDetailField get date {
    return _date = _setField(_date, 'date', DbType.date);
  }

  PaymentDetailField? _isDeleted;
  PaymentDetailField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<PaymentDetail> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPaymentDetail!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPaymentDetail!.delete(qparams);
    }
    return r;
  }

  /// Recover List<PaymentDetail> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover PaymentDetail bulk invoked');
    return _mnPaymentDetail!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from paymentDetails ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPaymentDetail!.updateBatch(qparams, values);
  }

  /// This method always returns [PaymentDetail] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaymentDetail?
  @override
  Future<PaymentDetail?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPaymentDetail!.toList(qparams);
    final data = await objFuture;
    PaymentDetail? obj;
    if (data.isNotEmpty) {
      obj = PaymentDetail.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PaymentDetail]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaymentDetail?
  @override
  Future<PaymentDetail> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PaymentDetail();
  }

  /// This method returns int. [PaymentDetail]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? paymentdetailCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final paymentdetailsFuture = await _mnPaymentDetail!.toList(qparams);
    final int count = paymentdetailsFuture[0]['CNT'] as int;
    if (paymentdetailCount != null) {
      paymentdetailCount(count);
    }
    return count;
  }

  /// This method returns List<PaymentDetail> [PaymentDetail]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PaymentDetail>
  @override
  Future<List<PaymentDetail>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PaymentDetail> paymentdetailsData =
        await PaymentDetail.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return paymentdetailsData;
  }

  /// This method returns Json String [PaymentDetail]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PaymentDetail]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PaymentDetail]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPaymentDetail!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PaymentDetail]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM paymentDetails WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPaymentDetail!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PaymentDetail]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPaymentDetail!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PaymentDetail.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPaymentDetail!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaymentDetailFilterBuilder

// region PaymentDetailFields
class PaymentDetailFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fPaymentMethodsId;
  static TableField get paymentMethodsId {
    return _fPaymentMethodsId = _fPaymentMethodsId ??
        SqlSyntax.setField(
            _fPaymentMethodsId, 'paymentMethodsId', DbType.integer);
  }

  static TableField? _fDetails;
  static TableField get details {
    return _fDetails =
        _fDetails ?? SqlSyntax.setField(_fDetails, 'details', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion PaymentDetailFields

//region PaymentDetailManager
class PaymentDetailManager extends SqfEntityProvider {
  PaymentDetailManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'paymentDetails';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PaymentDetailManager
// region Order
class Order extends TableBase {
  Order(
      {this.id,
      this.salesId,
      this.productId,
      this.quantity,
      this.amount,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Order.withFields(this.salesId, this.productId, this.quantity, this.amount,
      this.isDeleted) {
    _setDefaultValues();
  }
  Order.withId(this.id, this.salesId, this.productId, this.quantity,
      this.amount, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Order.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    salesId = int.tryParse(o['salesId'].toString());

    productId = int.tryParse(o['productId'].toString());

    if (o['quantity'] != null) {
      quantity = int.tryParse(o['quantity'].toString());
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plSale = o['sale'] != null
        ? Sale.fromMap(o['sale'] as Map<String, dynamic>)
        : null;
    plProduct = o['product'] != null
        ? Product.fromMap(o['product'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Order)
  int? id;
  int? salesId;
  int? productId;
  int? quantity;
  double? amount;
  bool? isDeleted;

  // end FIELDS (Order)

// RELATIONSHIPS (Order)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSale', 'plField2'..]) or so on..
  Sale? plSale;

  /// get Sale By SalesId
  Future<Sale?> getSale(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Sale()
        .getById(salesId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plProduct', 'plField2'..]) or so on..
  Product? plProduct;

  /// get Product By ProductId
  Future<Product?> getProduct(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Product().getById(productId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Order)

  static const bool _softDeleteActivated = true;
  OrderManager? __mnOrder;

  OrderManager get _mnOrder {
    return __mnOrder = __mnOrder ?? OrderManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (salesId != null) {
      map['salesId'] = forView
          ? plSale == null
              ? salesId
              : plSale!.id
          : salesId;
    } else if (salesId != null || !forView) {
      map['salesId'] = null;
    }
    if (productId != null) {
      map['productId'] = forView
          ? plProduct == null
              ? productId
              : plProduct!.name
          : productId;
    } else if (productId != null || !forView) {
      map['productId'] = null;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (salesId != null) {
      map['salesId'] = forView
          ? plSale == null
              ? salesId
              : plSale!.id
          : salesId;
    } else if (salesId != null || !forView) {
      map['salesId'] = null;
    }
    if (productId != null) {
      map['productId'] = forView
          ? plProduct == null
              ? productId
              : plProduct!.name
          : productId;
    } else if (productId != null || !forView) {
      map['productId'] = null;
    }
    if (quantity != null || !forView) {
      map['quantity'] = quantity;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Order]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Order]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [salesId, productId, quantity, amount, isDeleted];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, salesId, productId, quantity, amount, isDeleted];
  }

  static Future<List<Order>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Order.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Order>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Order>[];
    try {
      objList = list
          .map((order) => Order.fromMap(order as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Order.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Order>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Order> objList = <Order>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Order.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plProduct'))) {
          obj.plProduct =
              obj.plProduct ?? await obj.getProduct(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Order by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Order] if exist, otherwise returns null
  Future<Order?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Order? obj;
    final data = await _mnOrder.getById([id]);
    if (data.length != 0) {
      obj = Order.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plProduct'))) {
          obj.plProduct =
              obj.plProduct ?? await obj.getProduct(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Order) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnOrder.insert(this, ignoreBatch);
    } else {
      await _mnOrder.update(this);
    }

    return id;
  }

  /// Saves the (Order) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnOrder.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnOrder.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Order. Returns a new Primary Key value of Order

  /// <returns>Returns a new Primary Key value of Order
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Order> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Order> orders,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in orders) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < orders.length; i++) {
        if (orders[i].id == null) {
          orders[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOrder.rawInsert(
          'INSERT OR REPLACE INTO orders (id, salesId, productId, quantity, amount,isDeleted)  VALUES (?,?,?,?,?,?)',
          [id, salesId, productId, quantity, amount, isDeleted],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Order id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Order id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Order Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Order>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Order> orders,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnOrder.rawInsertAll(
        'INSERT OR REPLACE INTO orders (id, salesId, productId, quantity, amount,isDeleted)  VALUES (?,?,?,?,?,?)',
        orders,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Order

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Order invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnOrder
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnOrder.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Order

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Order invoked (id=$id)');
    {
      return _mnOrder.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  OrderFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OrderFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  OrderFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OrderFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    salesId = salesId ?? 0;
    productId = productId ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion order

// region OrderField
class OrderField extends FilterBase {
  OrderField(OrderFilterBuilder orderFB) : super(orderFB);

  @override
  OrderFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder isNull() {
    return super.isNull() as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as OrderFilterBuilder;
  }

  @override
  OrderFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as OrderFilterBuilder;
  }

  @override
  OrderField get not {
    return super.not as OrderField;
  }
}
// endregion OrderField

// region OrderFilterBuilder
class OrderFilterBuilder extends ConjunctionBase {
  OrderFilterBuilder(Order obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnOrder = obj._mnOrder;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  OrderManager? _mnOrder;

  /// put the sql keyword 'AND'
  @override
  OrderFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  OrderFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  OrderFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  OrderFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  OrderFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  OrderFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  OrderFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OrderFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OrderFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OrderFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OrderFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  OrderField _setField(OrderField? field, String colName, DbType dbtype) {
    return OrderField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  OrderField? _id;
  OrderField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  OrderField? _salesId;
  OrderField get salesId {
    return _salesId = _setField(_salesId, 'salesId', DbType.integer);
  }

  OrderField? _productId;
  OrderField get productId {
    return _productId = _setField(_productId, 'productId', DbType.integer);
  }

  OrderField? _quantity;
  OrderField get quantity {
    return _quantity = _setField(_quantity, 'quantity', DbType.integer);
  }

  OrderField? _amount;
  OrderField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  OrderField? _isDeleted;
  OrderField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Order> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnOrder!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnOrder!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Order> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Order bulk invoked');
    return _mnOrder!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from orders ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnOrder!.updateBatch(qparams, values);
  }

  /// This method always returns [Order] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Order?
  @override
  Future<Order?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnOrder!.toList(qparams);
    final data = await objFuture;
    Order? obj;
    if (data.isNotEmpty) {
      obj = Order.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plProduct'))) {
          obj.plProduct =
              obj.plProduct ?? await obj.getProduct(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Order]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Order?
  @override
  Future<Order> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Order();
  }

  /// This method returns int. [Order]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? orderCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final ordersFuture = await _mnOrder!.toList(qparams);
    final int count = ordersFuture[0]['CNT'] as int;
    if (orderCount != null) {
      orderCount(count);
    }
    return count;
  }

  /// This method returns List<Order> [Order]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Order>
  @override
  Future<List<Order>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Order> ordersData = await Order.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return ordersData;
  }

  /// This method returns Json String [Order]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Order]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Order]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnOrder!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Order]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM orders WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnOrder!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Order]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnOrder!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Order.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnOrder!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion OrderFilterBuilder

// region OrderFields
class OrderFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSalesId;
  static TableField get salesId {
    return _fSalesId =
        _fSalesId ?? SqlSyntax.setField(_fSalesId, 'salesId', DbType.integer);
  }

  static TableField? _fProductId;
  static TableField get productId {
    return _fProductId = _fProductId ??
        SqlSyntax.setField(_fProductId, 'productId', DbType.integer);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'quantity', DbType.integer);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion OrderFields

//region OrderManager
class OrderManager extends SqfEntityProvider {
  OrderManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'orders';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion OrderManager
// region Invoice
class Invoice extends TableBase {
  Invoice(
      {this.id,
      this.salesId,
      this.customer_name,
      this.invoice_number,
      this.amount,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Invoice.withFields(this.salesId, this.customer_name, this.invoice_number,
      this.amount, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  Invoice.withId(this.id, this.salesId, this.customer_name, this.invoice_number,
      this.amount, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Invoice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    salesId = int.tryParse(o['salesId'].toString());

    if (o['customer_name'] != null) {
      customer_name = o['customer_name'].toString();
    }
    if (o['invoice_number'] != null) {
      invoice_number = o['invoice_number'].toString();
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plSale = o['sale'] != null
        ? Sale.fromMap(o['sale'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Invoice)
  int? id;
  int? salesId;
  String? customer_name;
  String? invoice_number;
  double? amount;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Invoice)

// RELATIONSHIPS (Invoice)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSale', 'plField2'..]) or so on..
  Sale? plSale;

  /// get Sale By SalesId
  Future<Sale?> getSale(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Sale()
        .getById(salesId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Invoice)

  static const bool _softDeleteActivated = true;
  InvoiceManager? __mnInvoice;

  InvoiceManager get _mnInvoice {
    return __mnInvoice = __mnInvoice ?? InvoiceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (salesId != null) {
      map['salesId'] = forView
          ? plSale == null
              ? salesId
              : plSale!.id
          : salesId;
    } else if (salesId != null || !forView) {
      map['salesId'] = null;
    }
    if (customer_name != null || !forView) {
      map['customer_name'] = customer_name;
    }
    if (invoice_number != null || !forView) {
      map['invoice_number'] = invoice_number;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (salesId != null) {
      map['salesId'] = forView
          ? plSale == null
              ? salesId
              : plSale!.id
          : salesId;
    } else if (salesId != null || !forView) {
      map['salesId'] = null;
    }
    if (customer_name != null || !forView) {
      map['customer_name'] = customer_name;
    }
    if (invoice_number != null || !forView) {
      map['invoice_number'] = invoice_number;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Invoice]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Invoice]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      salesId,
      customer_name,
      invoice_number,
      amount,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      salesId,
      customer_name,
      invoice_number,
      amount,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Invoice>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Invoice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Invoice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Invoice>[];
    try {
      objList = list
          .map((invoice) => Invoice.fromMap(invoice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Invoice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Invoice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Invoice> objList = <Invoice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Invoice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Invoice by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Invoice] if exist, otherwise returns null
  Future<Invoice?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Invoice? obj;
    final data = await _mnInvoice.getById([id]);
    if (data.length != 0) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Invoice) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInvoice.insert(this, ignoreBatch);
    } else {
      await _mnInvoice.update(this);
    }

    return id;
  }

  /// Saves the (Invoice) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInvoice.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoice.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Invoice. Returns a new Primary Key value of Invoice

  /// <returns>Returns a new Primary Key value of Invoice
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Invoice> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Invoice> invoices,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in invoices) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < invoices.length; i++) {
        if (invoices[i].id == null) {
          invoices[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInvoice.rawInsert(
          'INSERT OR REPLACE INTO invoice (id, salesId, customer_name, invoice_number, amount, date,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            salesId,
            customer_name,
            invoice_number,
            amount,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Invoice id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Invoice id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Invoice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Invoice>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Invoice> invoices,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnInvoice.rawInsertAll(
        'INSERT OR REPLACE INTO invoice (id, salesId, customer_name, invoice_number, amount, date,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        invoices,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Invoice

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Invoice invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnInvoice
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnInvoice.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Invoice

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Invoice invoked (id=$id)');
    {
      return _mnInvoice.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  InvoiceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InvoiceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    salesId = salesId ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion invoice

// region InvoiceField
class InvoiceField extends FilterBase {
  InvoiceField(InvoiceFilterBuilder invoiceFB) : super(invoiceFB);

  @override
  InvoiceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder isNull() {
    return super.isNull() as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceField get not {
    return super.not as InvoiceField;
  }
}
// endregion InvoiceField

// region InvoiceFilterBuilder
class InvoiceFilterBuilder extends ConjunctionBase {
  InvoiceFilterBuilder(Invoice obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInvoice = obj._mnInvoice;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InvoiceManager? _mnInvoice;

  /// put the sql keyword 'AND'
  @override
  InvoiceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InvoiceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InvoiceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InvoiceFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InvoiceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InvoiceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InvoiceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InvoiceField _setField(InvoiceField? field, String colName, DbType dbtype) {
    return InvoiceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InvoiceField? _id;
  InvoiceField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  InvoiceField? _salesId;
  InvoiceField get salesId {
    return _salesId = _setField(_salesId, 'salesId', DbType.integer);
  }

  InvoiceField? _customer_name;
  InvoiceField get customer_name {
    return _customer_name =
        _setField(_customer_name, 'customer_name', DbType.text);
  }

  InvoiceField? _invoice_number;
  InvoiceField get invoice_number {
    return _invoice_number =
        _setField(_invoice_number, 'invoice_number', DbType.text);
  }

  InvoiceField? _amount;
  InvoiceField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  InvoiceField? _date;
  InvoiceField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  InvoiceField? _isDeleted;
  InvoiceField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Invoice> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInvoice!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInvoice!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Invoice> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Invoice bulk invoked');
    return _mnInvoice!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from invoice ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInvoice!.updateBatch(qparams, values);
  }

  /// This method always returns [Invoice] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Invoice?
  @override
  Future<Invoice?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInvoice!.toList(qparams);
    final data = await objFuture;
    Invoice? obj;
    if (data.isNotEmpty) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Invoice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Invoice?
  @override
  Future<Invoice> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Invoice();
  }

  /// This method returns int. [Invoice]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? invoiceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicesFuture = await _mnInvoice!.toList(qparams);
    final int count = invoicesFuture[0]['CNT'] as int;
    if (invoiceCount != null) {
      invoiceCount(count);
    }
    return count;
  }

  /// This method returns List<Invoice> [Invoice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Invoice>
  @override
  Future<List<Invoice>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Invoice> invoicesData = await Invoice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return invoicesData;
  }

  /// This method returns Json String [Invoice]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Invoice]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Invoice]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInvoice!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Invoice]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM invoice WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnInvoice!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Invoice]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInvoice!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Invoice.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInvoice!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceFilterBuilder

// region InvoiceFields
class InvoiceFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSalesId;
  static TableField get salesId {
    return _fSalesId =
        _fSalesId ?? SqlSyntax.setField(_fSalesId, 'salesId', DbType.integer);
  }

  static TableField? _fCustomer_name;
  static TableField get customer_name {
    return _fCustomer_name = _fCustomer_name ??
        SqlSyntax.setField(_fCustomer_name, 'customer_name', DbType.text);
  }

  static TableField? _fInvoice_number;
  static TableField get invoice_number {
    return _fInvoice_number = _fInvoice_number ??
        SqlSyntax.setField(_fInvoice_number, 'invoice_number', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion InvoiceFields

//region InvoiceManager
class InvoiceManager extends SqfEntityProvider {
  InvoiceManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'invoice';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion InvoiceManager
// region Payment
class Payment extends TableBase {
  Payment(
      {this.id,
      this.number,
      this.paymentMethodsId,
      this.sale,
      this.amount,
      this.description,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Payment.withFields(this.number, this.paymentMethodsId, this.sale, this.amount,
      this.description, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  Payment.withId(this.id, this.number, this.paymentMethodsId, this.sale,
      this.amount, this.description, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Payment.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['number'] != null) {
      number = int.tryParse(o['number'].toString());
    }
    paymentMethodsId = int.tryParse(o['paymentMethodsId'].toString());

    sale = int.tryParse(o['sale'].toString());

    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plPaymentMethod = o['paymentMethod'] != null
        ? PaymentMethod.fromMap(o['paymentMethod'] as Map<String, dynamic>)
        : null;
    plSale = o['plSale'] != null
        ? Sale.fromMap(o['plSale'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Payment)
  int? id;
  int? number;
  int? paymentMethodsId;
  int? sale;
  double? amount;
  String? description;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Payment)

// RELATIONSHIPS (Payment)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPaymentMethod', 'plField2'..]) or so on..
  PaymentMethod? plPaymentMethod;

  /// get PaymentMethod By PaymentMethodsId
  Future<PaymentMethod?> getPaymentMethod(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await PaymentMethod().getById(paymentMethodsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSale', 'plField2'..]) or so on..
  Sale? plSale;

  /// get Sale By Sale
  Future<Sale?> getSale(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Sale()
        .getById(sale, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Payment)

  static const bool _softDeleteActivated = true;
  PaymentManager? __mnPayment;

  PaymentManager get _mnPayment {
    return __mnPayment = __mnPayment ?? PaymentManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (number != null || !forView) {
      map['number'] = number;
    }
    if (paymentMethodsId != null) {
      map['paymentMethodsId'] = forView
          ? plPaymentMethod == null
              ? paymentMethodsId
              : plPaymentMethod!.name
          : paymentMethodsId;
    } else if (paymentMethodsId != null || !forView) {
      map['paymentMethodsId'] = null;
    }
    if (sale != null) {
      map['sale'] = forView
          ? plSale == null
              ? sale
              : plSale!.id
          : sale;
    } else if (sale != null || !forView) {
      map['sale'] = null;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (number != null || !forView) {
      map['number'] = number;
    }
    if (paymentMethodsId != null) {
      map['paymentMethodsId'] = forView
          ? plPaymentMethod == null
              ? paymentMethodsId
              : plPaymentMethod!.name
          : paymentMethodsId;
    } else if (paymentMethodsId != null || !forView) {
      map['paymentMethodsId'] = null;
    }
    if (sale != null) {
      map['sale'] = forView
          ? plSale == null
              ? sale
              : plSale!.id
          : sale;
    } else if (sale != null || !forView) {
      map['sale'] = null;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Payment]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Payment]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      number,
      paymentMethodsId,
      sale,
      amount,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      number,
      paymentMethodsId,
      sale,
      amount,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Payment>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Payment.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Payment>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Payment>[];
    try {
      objList = list
          .map((payment) => Payment.fromMap(payment as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Payment.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Payment>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Payment> objList = <Payment>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Payment.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Payment by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Payment] if exist, otherwise returns null
  Future<Payment?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Payment? obj;
    final data = await _mnPayment.getById([id]);
    if (data.length != 0) {
      obj = Payment.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Payment) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      number = await IdentitySequence().nextVal();

      id = await _mnPayment.insert(this, ignoreBatch);
    } else {
      await _mnPayment.update(this);
    }

    return id;
  }

  /// Saves the (Payment) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      number = await IdentitySequence().nextVal();

      id = await _mnPayment.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPayment.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Payment. Returns a new Primary Key value of Payment

  /// <returns>Returns a new Primary Key value of Payment
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Payment> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Payment> payments,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in payments) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < payments.length; i++) {
        if (payments[i].id == null) {
          payments[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPayment.rawInsert(
          'INSERT OR REPLACE INTO payment (id, number, paymentMethodsId, sale, amount, description, date,isDeleted)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            number,
            paymentMethodsId,
            sale,
            amount,
            description,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Payment id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Payment id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Payment Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Payment>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Payment> payments,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPayment.rawInsertAll(
        'INSERT OR REPLACE INTO payment (id, number, paymentMethodsId, sale, amount, description, date,isDeleted)  VALUES (?,?,?,?,?,?,?,?)',
        payments,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Payment

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Payment invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnPayment
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPayment.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Payment

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Payment invoked (id=$id)');
    {
      return _mnPayment.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  PaymentFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PaymentFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaymentFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    paymentMethodsId = paymentMethodsId ?? 0;
    sale = sale ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion payment

// region PaymentField
class PaymentField extends FilterBase {
  PaymentField(PaymentFilterBuilder paymentFB) : super(paymentFB);

  @override
  PaymentFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder isNull() {
    return super.isNull() as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PaymentFilterBuilder;
  }

  @override
  PaymentField get not {
    return super.not as PaymentField;
  }
}
// endregion PaymentField

// region PaymentFilterBuilder
class PaymentFilterBuilder extends ConjunctionBase {
  PaymentFilterBuilder(Payment obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPayment = obj._mnPayment;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PaymentManager? _mnPayment;

  /// put the sql keyword 'AND'
  @override
  PaymentFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PaymentFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PaymentFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PaymentFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PaymentFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PaymentFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PaymentFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaymentFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaymentFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PaymentField _setField(PaymentField? field, String colName, DbType dbtype) {
    return PaymentField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PaymentField? _id;
  PaymentField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PaymentField? _number;
  PaymentField get number {
    return _number = _setField(_number, 'number', DbType.integer);
  }

  PaymentField? _paymentMethodsId;
  PaymentField get paymentMethodsId {
    return _paymentMethodsId =
        _setField(_paymentMethodsId, 'paymentMethodsId', DbType.integer);
  }

  PaymentField? _sale;
  PaymentField get sale {
    return _sale = _setField(_sale, 'sale', DbType.integer);
  }

  PaymentField? _amount;
  PaymentField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  PaymentField? _description;
  PaymentField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  PaymentField? _date;
  PaymentField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  PaymentField? _isDeleted;
  PaymentField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Payment> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPayment!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPayment!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Payment> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Payment bulk invoked');
    return _mnPayment!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from payment ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPayment!.updateBatch(qparams, values);
  }

  /// This method always returns [Payment] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Payment?
  @override
  Future<Payment?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPayment!.toList(qparams);
    final data = await objFuture;
    Payment? obj;
    if (data.isNotEmpty) {
      obj = Payment.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPaymentMethod'))) {
          obj.plPaymentMethod = obj.plPaymentMethod ??
              await obj.getPaymentMethod(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSale'))) {
          obj.plSale =
              obj.plSale ?? await obj.getSale(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Payment]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Payment?
  @override
  Future<Payment> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Payment();
  }

  /// This method returns int. [Payment]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? paymentCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final paymentsFuture = await _mnPayment!.toList(qparams);
    final int count = paymentsFuture[0]['CNT'] as int;
    if (paymentCount != null) {
      paymentCount(count);
    }
    return count;
  }

  /// This method returns List<Payment> [Payment]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Payment>
  @override
  Future<List<Payment>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Payment> paymentsData = await Payment.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return paymentsData;
  }

  /// This method returns Json String [Payment]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Payment]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Payment]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPayment!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Payment]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM payment WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPayment!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Payment]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPayment!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Payment.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPayment!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaymentFilterBuilder

// region PaymentFields
class PaymentFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNumber;
  static TableField get number {
    return _fNumber =
        _fNumber ?? SqlSyntax.setField(_fNumber, 'number', DbType.integer);
  }

  static TableField? _fPaymentMethodsId;
  static TableField get paymentMethodsId {
    return _fPaymentMethodsId = _fPaymentMethodsId ??
        SqlSyntax.setField(
            _fPaymentMethodsId, 'paymentMethodsId', DbType.integer);
  }

  static TableField? _fSale;
  static TableField get sale {
    return _fSale =
        _fSale ?? SqlSyntax.setField(_fSale, 'sale', DbType.integer);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion PaymentFields

//region PaymentManager
class PaymentManager extends SqfEntityProvider {
  PaymentManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'payment';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PaymentManager
// region Sale
class Sale extends TableBase {
  Sale({this.id, this.date, this.isCredit, this.amount, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Sale.withFields(this.date, this.isCredit, this.amount, this.isDeleted) {
    _setDefaultValues();
  }
  Sale.withId(this.id, this.date, this.isCredit, this.amount, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Sale.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['isCredit'] != null) {
      isCredit =
          o['isCredit'].toString() == '1' || o['isCredit'].toString() == 'true';
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Sale)
  int? id;
  DateTime? date;
  bool? isCredit;
  double? amount;
  bool? isDeleted;

  // end FIELDS (Sale)

// COLLECTIONS & VIRTUALS (Sale)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plOrders', 'plField2'..]) or so on..
  List<Order>? plOrders;

  /// get Order(s) filtered by id=salesId
  OrderFilterBuilder? getOrders(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Order()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .salesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plInvoices', 'plField2'..]) or so on..
  List<Invoice>? plInvoices;

  /// get Invoice(s) filtered by id=salesId
  InvoiceFilterBuilder? getInvoices(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Invoice()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .salesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPayments', 'plField2'..]) or so on..
  List<Payment>? plPayments;

  /// get Payment(s) filtered by id=sale
  PaymentFilterBuilder? getPayments(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Payment()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .sale
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Sale)

  static const bool _softDeleteActivated = true;
  SaleManager? __mnSale;

  SaleManager get _mnSale {
    return __mnSale = __mnSale ?? SaleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isCredit != null) {
      map['isCredit'] = forQuery ? (isCredit! ? 1 : 0) : isCredit;
    } else if (isCredit != null || !forView) {
      map['isCredit'] = null;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isCredit != null) {
      map['isCredit'] = forQuery ? (isCredit! ? 1 : 0) : isCredit;
    } else if (isCredit != null || !forView) {
      map['isCredit'] = null;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Sale)
    if (!forQuery) {
      map['Orders'] = await getOrders()!.toMapList();
    }
    if (!forQuery) {
      map['Invoices'] = await getInvoices()!.toMapList();
    }
    if (!forQuery) {
      map['Payments'] = await getPayments()!.toMapList();
    }
// END COLLECTIONS (Sale)

    return map;
  }

  /// This method returns Json String [Sale]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Sale]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      date != null ? date!.millisecondsSinceEpoch : null,
      isCredit,
      amount,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      date != null ? date!.millisecondsSinceEpoch : null,
      isCredit,
      amount,
      isDeleted
    ];
  }

  static Future<List<Sale>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Sale.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Sale>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Sale>[];
    try {
      objList = list
          .map((sale) => Sale.fromMap(sale as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Sale.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Sale>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Sale> objList = <Sale>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Sale.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('sales.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('sales.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('sales.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('sales.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Sale by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Sale] if exist, otherwise returns null
  Future<Sale?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Sale? obj;
    final data = await _mnSale.getById([id]);
    if (data.length != 0) {
      obj = Sale.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('sales.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('sales.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('sales.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('sales.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Sale) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSale.insert(this, ignoreBatch);
    } else {
      await _mnSale.update(this);
    }

    return id;
  }

  /// Saves the (Sale) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSale.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSale.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Sale. Returns a new Primary Key value of Sale

  /// <returns>Returns a new Primary Key value of Sale
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Sale> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Sale> sales,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in sales) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < sales.length; i++) {
        if (sales[i].id == null) {
          sales[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSale.rawInsert(
          'INSERT OR REPLACE INTO sales (id, date, isCredit, amount,isDeleted)  VALUES (?,?,?,?,?)',
          [
            id,
            date != null ? date!.millisecondsSinceEpoch : null,
            isCredit,
            amount,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Sale id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Sale id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Sale Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Sale>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Sale> sales,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSale.rawInsertAll(
        'INSERT OR REPLACE INTO sales (id, date, isCredit, amount,isDeleted)  VALUES (?,?,?,?,?)',
        sales,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Sale

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Sale invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Order().select().salesId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result =
          await Invoice().select().salesId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await Payment().select().sale.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnSale
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSale.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Sale

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Sale invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await Order()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .salesId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await Invoice()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .salesId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await Payment()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .sale
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnSale.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  SaleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SaleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SaleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SaleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion sale

// region SaleField
class SaleField extends FilterBase {
  SaleField(SaleFilterBuilder saleFB) : super(saleFB);

  @override
  SaleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder isNull() {
    return super.isNull() as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SaleFilterBuilder;
  }

  @override
  SaleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SaleFilterBuilder;
  }

  @override
  SaleField get not {
    return super.not as SaleField;
  }
}
// endregion SaleField

// region SaleFilterBuilder
class SaleFilterBuilder extends ConjunctionBase {
  SaleFilterBuilder(Sale obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnSale = obj._mnSale;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SaleManager? _mnSale;

  /// put the sql keyword 'AND'
  @override
  SaleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SaleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SaleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SaleFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SaleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SaleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SaleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SaleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SaleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SaleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SaleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SaleField _setField(SaleField? field, String colName, DbType dbtype) {
    return SaleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SaleField? _id;
  SaleField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SaleField? _date;
  SaleField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  SaleField? _isCredit;
  SaleField get isCredit {
    return _isCredit = _setField(_isCredit, 'isCredit', DbType.bool);
  }

  SaleField? _amount;
  SaleField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  SaleField? _isDeleted;
  SaleField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Sale> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Order) according to DeleteRule.CASCADE
    final idListOrderBYsalesId = toListPrimaryKeySQL(false);
    final resOrderBYsalesId = await Order()
        .select()
        .where('salesId IN (${idListOrderBYsalesId['sql']})',
            parameterValue: idListOrderBYsalesId['args'])
        .delete(hardDelete);
    if (!resOrderBYsalesId.success) {
      return resOrderBYsalesId;
    }
// Delete sub records where in (Invoice) according to DeleteRule.CASCADE
    final idListInvoiceBYsalesId = toListPrimaryKeySQL(false);
    final resInvoiceBYsalesId = await Invoice()
        .select()
        .where('salesId IN (${idListInvoiceBYsalesId['sql']})',
            parameterValue: idListInvoiceBYsalesId['args'])
        .delete(hardDelete);
    if (!resInvoiceBYsalesId.success) {
      return resInvoiceBYsalesId;
    }
// Delete sub records where in (Payment) according to DeleteRule.CASCADE
    final idListPaymentBYsale = toListPrimaryKeySQL(false);
    final resPaymentBYsale = await Payment()
        .select()
        .where('sale IN (${idListPaymentBYsale['sql']})',
            parameterValue: idListPaymentBYsale['args'])
        .delete(hardDelete);
    if (!resPaymentBYsale.success) {
      return resPaymentBYsale;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSale!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSale!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Sale> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Sale bulk invoked');
    // Recover sub records where in (Order) according to DeleteRule.CASCADE
    final idListOrderBYsalesId = toListPrimaryKeySQL(false);
    final resOrderBYsalesId = await Order()
        .select()
        .where('salesId IN (${idListOrderBYsalesId['sql']})',
            parameterValue: idListOrderBYsalesId['args'])
        .update({'isDeleted': 0});
    if (!resOrderBYsalesId.success) {
      return resOrderBYsalesId;
    }
// Recover sub records where in (Invoice) according to DeleteRule.CASCADE
    final idListInvoiceBYsalesId = toListPrimaryKeySQL(false);
    final resInvoiceBYsalesId = await Invoice()
        .select()
        .where('salesId IN (${idListInvoiceBYsalesId['sql']})',
            parameterValue: idListInvoiceBYsalesId['args'])
        .update({'isDeleted': 0});
    if (!resInvoiceBYsalesId.success) {
      return resInvoiceBYsalesId;
    }
// Recover sub records where in (Payment) according to DeleteRule.CASCADE
    final idListPaymentBYsale = toListPrimaryKeySQL(false);
    final resPaymentBYsale = await Payment()
        .select()
        .where('sale IN (${idListPaymentBYsale['sql']})',
            parameterValue: idListPaymentBYsale['args'])
        .update({'isDeleted': 0});
    if (!resPaymentBYsale.success) {
      return resPaymentBYsale;
    }
    return _mnSale!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from sales ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSale!.updateBatch(qparams, values);
  }

  /// This method always returns [Sale] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Sale?
  @override
  Future<Sale?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSale!.toList(qparams);
    final data = await objFuture;
    Sale? obj;
    if (data.isNotEmpty) {
      obj = Sale.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('sales.plOrders') && */ (preloadFields ==
                null ||
            preloadFields.contains('plOrders'))) {
          /*_loadedfields!.add('sales.plOrders'); */ obj.plOrders =
              obj.plOrders ??
                  await obj.getOrders()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('sales.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('sales.plPayments') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPayments'))) {
          /*_loadedfields!.add('sales.plPayments'); */ obj.plPayments =
              obj.plPayments ??
                  await obj.getPayments()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Sale]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Sale?
  @override
  Future<Sale> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Sale();
  }

  /// This method returns int. [Sale]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? saleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final salesFuture = await _mnSale!.toList(qparams);
    final int count = salesFuture[0]['CNT'] as int;
    if (saleCount != null) {
      saleCount(count);
    }
    return count;
  }

  /// This method returns List<Sale> [Sale]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Sale>
  @override
  Future<List<Sale>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Sale> salesData = await Sale.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return salesData;
  }

  /// This method returns Json String [Sale]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Sale]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Sale]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSale!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Sale]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM sales WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSale!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Sale]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSale!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Sale.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSale!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SaleFilterBuilder

// region SaleFields
class SaleFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsCredit;
  static TableField get isCredit {
    return _fIsCredit =
        _fIsCredit ?? SqlSyntax.setField(_fIsCredit, 'isCredit', DbType.bool);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion SaleFields

//region SaleManager
class SaleManager extends SqfEntityProvider {
  SaleManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'sales';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SaleManager
// region Period
class Period extends TableBase {
  Period({this.id, this.start_date, this.end_date, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Period.withFields(this.start_date, this.end_date, this.isDeleted) {
    _setDefaultValues();
  }
  Period.withId(this.id, this.start_date, this.end_date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Period.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['start_date'] != null) {
      start_date = int.tryParse(o['start_date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['start_date'].toString())!)
          : DateTime.tryParse(o['start_date'].toString());
    }
    if (o['end_date'] != null) {
      end_date = int.tryParse(o['end_date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['end_date'].toString())!)
          : DateTime.tryParse(o['end_date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Period)
  int? id;
  DateTime? start_date;
  DateTime? end_date;
  bool? isDeleted;

  // end FIELDS (Period)

// COLLECTIONS & VIRTUALS (Period)
  ProfitAndLoss? _profitandloss;
  ProfitAndLoss get profitandloss {
    return _profitandloss = _profitandloss ?? ProfitAndLoss();
  }

  set profitandloss(ProfitAndLoss profitandloss) {
    _profitandloss = profitandloss;
  }

// END COLLECTIONS & VIRTUALS (Period)

  static const bool _softDeleteActivated = true;
  PeriodManager? __mnPeriod;

  PeriodManager get _mnPeriod {
    return __mnPeriod = __mnPeriod ?? PeriodManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (start_date != null) {
      map['start_date'] = forJson
          ? '$start_date!.year-$start_date!.month-$start_date!.day'
          : forQuery
              ? DateTime(start_date!.year, start_date!.month, start_date!.day)
                  .millisecondsSinceEpoch
              : start_date;
    } else if (start_date != null || !forView) {
      map['start_date'] = null;
    }
    if (end_date != null) {
      map['end_date'] = forJson
          ? '$end_date!.year-$end_date!.month-$end_date!.day'
          : forQuery
              ? DateTime(end_date!.year, end_date!.month, end_date!.day)
                  .millisecondsSinceEpoch
              : end_date;
    } else if (end_date != null || !forView) {
      map['end_date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (start_date != null) {
      map['start_date'] = forJson
          ? '$start_date!.year-$start_date!.month-$start_date!.day'
          : forQuery
              ? DateTime(start_date!.year, start_date!.month, start_date!.day)
                  .millisecondsSinceEpoch
              : start_date;
    } else if (start_date != null || !forView) {
      map['start_date'] = null;
    }
    if (end_date != null) {
      map['end_date'] = forJson
          ? '$end_date!.year-$end_date!.month-$end_date!.day'
          : forQuery
              ? DateTime(end_date!.year, end_date!.month, end_date!.day)
                  .millisecondsSinceEpoch
              : end_date;
    } else if (end_date != null || !forView) {
      map['end_date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Period)
    if (!forQuery) {
      map['profitandloss'] = await profitandloss.toMapWithChildren();
    }
// END COLLECTIONS (Period)

    return map;
  }

  /// This method returns Json String [Period]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Period]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      start_date != null ? start_date!.millisecondsSinceEpoch : null,
      end_date != null ? end_date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      start_date != null ? start_date!.millisecondsSinceEpoch : null,
      end_date != null ? end_date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Period>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Period.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Period>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Period>[];
    try {
      objList = list
          .map((period) => Period.fromMap(period as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Period.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Period>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Period> objList = <Period>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Period.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

//      RELATIONS OneToOne (Period)
      obj._profitandloss = await ProfitAndLoss()
          .select()
          ._periodId
          .equals(obj.id)
          .toSingle(); //      END RELATIONS OneToOne (Period)

      objList.add(obj);
    }
    return objList;
  }

  /// returns Period by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Period] if exist, otherwise returns null
  Future<Period?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Period? obj;
    final data = await _mnPeriod.getById([id]);
    if (data.length != 0) {
      obj = Period.fromMap(data[0] as Map<String, dynamic>);

//      RELATIONS OneToOne (Period)
      obj._profitandloss = await ProfitAndLoss()
          .select()
          ._periodId
          .equals(obj.id)
          .toSingle(); //      END RELATIONS OneToOne (Period)
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Period) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPeriod.insert(this, ignoreBatch);
    } else {
      await _mnPeriod.update(this);
    }

// save() OneToOne relations (Period)
    _profitandloss?._periodId = id;
    await _profitandloss?._save();
// END save() OneToOne relations (Period)

    return id;
  }

  /// Saves the (Period) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPeriod.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPeriod.updateOrThrow(this);
    }

// save() OneToOne relations (Period)
    _profitandloss?._periodId = id;
    await _profitandloss?._save();
// END save() OneToOne relations (Period)

    return id;
  }

  /// saveAs Period. Returns a new Primary Key value of Period

  /// <returns>Returns a new Primary Key value of Period
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

// saveAs() OneToOne relations (Period)
    profitandloss.id = null;
// END saveAs() OneToOne relations (Period)

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Period> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Period> periods,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in periods) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < periods.length; i++) {
        if (periods[i].id == null) {
          periods[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPeriod.rawInsert(
          'INSERT OR REPLACE INTO period (id, start_date, end_date,isDeleted)  VALUES (?,?,?,?)',
          [
            id,
            start_date != null ? start_date!.millisecondsSinceEpoch : null,
            end_date != null ? end_date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Period id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Period id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Period Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Period>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Period> periods,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPeriod.rawInsertAll(
        'INSERT OR REPLACE INTO period (id, start_date, end_date,isDeleted)  VALUES (?,?,?,?)',
        periods,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Period

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Period invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await ProfitAndLoss()
          .select()
          ._periodId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnPeriod
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPeriod.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Period

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Period invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await ProfitAndLoss()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          ._periodId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnPeriod.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  PeriodFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PeriodFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion period

// region PeriodField
class PeriodField extends FilterBase {
  PeriodField(PeriodFilterBuilder periodFB) : super(periodFB);

  @override
  PeriodFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder isNull() {
    return super.isNull() as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PeriodFilterBuilder;
  }

  @override
  PeriodField get not {
    return super.not as PeriodField;
  }
}
// endregion PeriodField

// region PeriodFilterBuilder
class PeriodFilterBuilder extends ConjunctionBase {
  PeriodFilterBuilder(Period obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPeriod = obj._mnPeriod;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PeriodManager? _mnPeriod;

  /// put the sql keyword 'AND'
  @override
  PeriodFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PeriodFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PeriodFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PeriodFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PeriodFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PeriodFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PeriodFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PeriodField _setField(PeriodField? field, String colName, DbType dbtype) {
    return PeriodField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PeriodField? _id;
  PeriodField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PeriodField? _start_date;
  PeriodField get start_date {
    return _start_date = _setField(_start_date, 'start_date', DbType.date);
  }

  PeriodField? _end_date;
  PeriodField get end_date {
    return _end_date = _setField(_end_date, 'end_date', DbType.date);
  }

  PeriodField? _isDeleted;
  PeriodField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Period> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (ProfitAndLoss) according to DeleteRule.CASCADE
    final idListProfitAndLossBY_periodId = toListPrimaryKeySQL(false);
    final resProfitAndLossBY_periodId = await ProfitAndLoss()
        .select()
        .where('_periodId IN (${idListProfitAndLossBY_periodId['sql']})',
            parameterValue: idListProfitAndLossBY_periodId['args'])
        .delete(hardDelete);
    if (!resProfitAndLossBY_periodId.success) {
      return resProfitAndLossBY_periodId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPeriod!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPeriod!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Period> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Period bulk invoked');
    // Recover sub records where in (ProfitAndLoss) according to DeleteRule.CASCADE
    final idListProfitAndLossBY_periodId = toListPrimaryKeySQL(false);
    final resProfitAndLossBY_periodId = await ProfitAndLoss()
        .select()
        .where('_periodId IN (${idListProfitAndLossBY_periodId['sql']})',
            parameterValue: idListProfitAndLossBY_periodId['args'])
        .update({'isDeleted': 0});
    if (!resProfitAndLossBY_periodId.success) {
      return resProfitAndLossBY_periodId;
    }
    return _mnPeriod!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from period ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPeriod!.updateBatch(qparams, values);
  }

  /// This method always returns [Period] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Period?
  @override
  Future<Period?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPeriod!.toList(qparams);
    final data = await objFuture;
    Period? obj;
    if (data.isNotEmpty) {
      obj = Period.fromMap(data[0] as Map<String, dynamic>);

//      RELATIONS OneToOne (Period)
      obj._profitandloss = await ProfitAndLoss()
          .select()
          ._periodId
          .equals(obj.id)
          .toSingle(); //      END RELATIONS OneToOne (Period)
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Period]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Period?
  @override
  Future<Period> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Period();
  }

  /// This method returns int. [Period]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? periodCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final periodsFuture = await _mnPeriod!.toList(qparams);
    final int count = periodsFuture[0]['CNT'] as int;
    if (periodCount != null) {
      periodCount(count);
    }
    return count;
  }

  /// This method returns List<Period> [Period]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Period>
  @override
  Future<List<Period>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Period> periodsData = await Period.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return periodsData;
  }

  /// This method returns Json String [Period]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Period]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Period]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPeriod!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Period]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM period WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPeriod!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Period]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPeriod!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Period.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPeriod!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PeriodFilterBuilder

// region PeriodFields
class PeriodFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fStart_date;
  static TableField get start_date {
    return _fStart_date = _fStart_date ??
        SqlSyntax.setField(_fStart_date, 'start_date', DbType.date);
  }

  static TableField? _fEnd_date;
  static TableField get end_date {
    return _fEnd_date =
        _fEnd_date ?? SqlSyntax.setField(_fEnd_date, 'end_date', DbType.date);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion PeriodFields

//region PeriodManager
class PeriodManager extends SqfEntityProvider {
  PeriodManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'period';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PeriodManager
// region Expense
class Expense extends TableBase {
  Expense(
      {this.id,
      this.name,
      this.amount,
      this.description,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Expense.withFields(
      this.name, this.amount, this.description, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  Expense.withId(this.id, this.name, this.amount, this.description, this.date,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Expense.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['amount'] != null) {
      amount = double.tryParse(o['amount'].toString());
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Expense)
  int? id;
  String? name;
  double? amount;
  String? description;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (Expense)

  static const bool _softDeleteActivated = true;
  ExpenseManager? __mnExpense;

  ExpenseManager get _mnExpense {
    return __mnExpense = __mnExpense ?? ExpenseManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (amount != null || !forView) {
      map['amount'] = amount;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Expense]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Expense]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      amount,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      amount,
      description,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Expense>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Expense.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Expense>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Expense>[];
    try {
      objList = list
          .map((expense) => Expense.fromMap(expense as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Expense.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Expense>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Expense> objList = <Expense>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Expense.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Expense by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Expense] if exist, otherwise returns null
  Future<Expense?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Expense? obj;
    final data = await _mnExpense.getById([id]);
    if (data.length != 0) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Expense) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExpense.insert(this, ignoreBatch);
    } else {
      await _mnExpense.update(this);
    }

    return id;
  }

  /// Saves the (Expense) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExpense.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpense.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Expense. Returns a new Primary Key value of Expense

  /// <returns>Returns a new Primary Key value of Expense
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Expense> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Expense> expenses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in expenses) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < expenses.length; i++) {
        if (expenses[i].id == null) {
          expenses[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExpense.rawInsert(
          'INSERT OR REPLACE INTO expense (id, name, amount, description, date,isDeleted)  VALUES (?,?,?,?,?,?)',
          [
            id,
            name,
            amount,
            description,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Expense id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Expense id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Expense Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Expense>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Expense> expenses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnExpense.rawInsertAll(
        'INSERT OR REPLACE INTO expense (id, name, amount, description, date,isDeleted)  VALUES (?,?,?,?,?,?)',
        expenses,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Expense

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Expense invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnExpense
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExpense.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Expense

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Expense invoked (id=$id)');
    {
      return _mnExpense.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ExpenseFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExpenseFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExpenseFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExpenseFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion expense

// region ExpenseField
class ExpenseField extends FilterBase {
  ExpenseField(ExpenseFilterBuilder expenseFB) : super(expenseFB);

  @override
  ExpenseFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder isNull() {
    return super.isNull() as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExpenseFilterBuilder;
  }

  @override
  ExpenseField get not {
    return super.not as ExpenseField;
  }
}
// endregion ExpenseField

// region ExpenseFilterBuilder
class ExpenseFilterBuilder extends ConjunctionBase {
  ExpenseFilterBuilder(Expense obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExpense = obj._mnExpense;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExpenseManager? _mnExpense;

  /// put the sql keyword 'AND'
  @override
  ExpenseFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExpenseFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExpenseFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExpenseFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExpenseFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExpenseFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExpenseFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExpenseFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExpenseFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExpenseFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExpenseFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExpenseField _setField(ExpenseField? field, String colName, DbType dbtype) {
    return ExpenseField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExpenseField? _id;
  ExpenseField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ExpenseField? _name;
  ExpenseField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  ExpenseField? _amount;
  ExpenseField get amount {
    return _amount = _setField(_amount, 'amount', DbType.real);
  }

  ExpenseField? _description;
  ExpenseField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  ExpenseField? _date;
  ExpenseField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  ExpenseField? _isDeleted;
  ExpenseField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Expense> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExpense!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExpense!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Expense> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Expense bulk invoked');
    return _mnExpense!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from expense ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExpense!.updateBatch(qparams, values);
  }

  /// This method always returns [Expense] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Expense?
  @override
  Future<Expense?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExpense!.toList(qparams);
    final data = await objFuture;
    Expense? obj;
    if (data.isNotEmpty) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Expense]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Expense?
  @override
  Future<Expense> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Expense();
  }

  /// This method returns int. [Expense]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? expenseCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensesFuture = await _mnExpense!.toList(qparams);
    final int count = expensesFuture[0]['CNT'] as int;
    if (expenseCount != null) {
      expenseCount(count);
    }
    return count;
  }

  /// This method returns List<Expense> [Expense]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Expense>
  @override
  Future<List<Expense>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Expense> expensesData = await Expense.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return expensesData;
  }

  /// This method returns Json String [Expense]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Expense]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Expense]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExpense!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Expense]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM expense WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnExpense!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Expense]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExpense!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Expense.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExpense!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpenseFilterBuilder

// region ExpenseFields
class ExpenseFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'amount', DbType.real);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ExpenseFields

//region ExpenseManager
class ExpenseManager extends SqfEntityProvider {
  ExpenseManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'expense';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExpenseManager
// region ProfitAndLoss
class ProfitAndLoss extends TableBase {
  ProfitAndLoss(
      {this.revenue,
      this.cost,
      this.expense,
      this.profit,
      this.date,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  ProfitAndLoss.withFields(this._periodId, this.revenue, this.cost,
      this.expense, this.profit, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  ProfitAndLoss.withId(this._periodId, this.revenue, this.cost, this.expense,
      this.profit, this.date, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ProfitAndLoss.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    _periodId = int.tryParse(o['_periodId'].toString());

    if (o['revenue'] != null) {
      revenue = double.tryParse(o['revenue'].toString());
    }
    if (o['cost'] != null) {
      cost = double.tryParse(o['cost'].toString());
    }
    if (o['expense'] != null) {
      expense = double.tryParse(o['expense'].toString());
    }
    if (o['profit'] != null) {
      profit = double.tryParse(o['profit'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (ProfitAndLoss)
  int? id;
  int? _periodId;
  double? revenue;
  double? cost;
  double? expense;
  double? profit;
  DateTime? date;
  bool? isDeleted;

  // end FIELDS (ProfitAndLoss)

  static const bool _softDeleteActivated = true;
  ProfitAndLossManager? __mnProfitAndLoss;

  ProfitAndLossManager get _mnProfitAndLoss {
    return __mnProfitAndLoss = __mnProfitAndLoss ?? ProfitAndLossManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['_periodId'] = _periodId;
    if (revenue != null || !forView) {
      map['revenue'] = revenue;
    }
    if (cost != null || !forView) {
      map['cost'] = cost;
    }
    if (expense != null || !forView) {
      map['expense'] = expense;
    }
    if (profit != null || !forView) {
      map['profit'] = profit;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['_periodId'] = _periodId;
    if (revenue != null || !forView) {
      map['revenue'] = revenue;
    }
    if (cost != null || !forView) {
      map['cost'] = cost;
    }
    if (expense != null || !forView) {
      map['expense'] = expense;
    }
    if (profit != null || !forView) {
      map['profit'] = profit;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [ProfitAndLoss]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ProfitAndLoss]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      _periodId,
      revenue,
      cost,
      expense,
      profit,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      _periodId,
      revenue,
      cost,
      expense,
      profit,
      date != null ? date!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<ProfitAndLoss>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProfitAndLoss.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ProfitAndLoss>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ProfitAndLoss>[];
    try {
      objList = list
          .map((profitandloss) =>
              ProfitAndLoss.fromMap(profitandloss as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProfitAndLoss.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ProfitAndLoss>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ProfitAndLoss> objList = <ProfitAndLoss>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ProfitAndLoss.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ProfitAndLoss by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ProfitAndLoss] if exist, otherwise returns null
  Future<ProfitAndLoss?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ProfitAndLoss? obj;
    final data = await _mnProfitAndLoss.getById([id]);
    if (data.length != 0) {
      obj = ProfitAndLoss.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ProfitAndLoss) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> _save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProfitAndLoss.insert(this, ignoreBatch);
    } else {
      await _mnProfitAndLoss.update(this);
    }

    return id;
  }

  /// Saves the (ProfitAndLoss) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> _saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProfitAndLoss.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProfitAndLoss.updateOrThrow(this);
    }

    return id;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProfitAndLoss.rawInsert(
          'INSERT OR REPLACE INTO profitAndLoss ( _periodId, revenue, cost, expense, profit, date,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            _periodId,
            revenue,
            cost,
            expense,
            profit,
            date != null ? date!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ProfitAndLoss id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProfitAndLoss id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProfitAndLoss Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ProfitAndLoss

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ProfitAndLoss invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnProfitAndLoss
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProfitAndLoss.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover ProfitAndLoss

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover ProfitAndLoss invoked (id=$id)');
    {
      return _mnProfitAndLoss.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ProfitAndLossFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProfitAndLossFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProfitAndLossFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProfitAndLossFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    _periodId = _periodId ?? 0;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion profitandloss

// region ProfitAndLossField
class ProfitAndLossField extends FilterBase {
  ProfitAndLossField(ProfitAndLossFilterBuilder profitandlossFB)
      : super(profitandlossFB);

  @override
  ProfitAndLossFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder isNull() {
    return super.isNull() as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProfitAndLossFilterBuilder;
  }

  @override
  ProfitAndLossField get not {
    return super.not as ProfitAndLossField;
  }
}
// endregion ProfitAndLossField

// region ProfitAndLossFilterBuilder
class ProfitAndLossFilterBuilder extends ConjunctionBase {
  ProfitAndLossFilterBuilder(ProfitAndLoss obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProfitAndLoss = obj._mnProfitAndLoss;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProfitAndLossManager? _mnProfitAndLoss;

  /// put the sql keyword 'AND'
  @override
  ProfitAndLossFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProfitAndLossFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProfitAndLossFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProfitAndLossFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProfitAndLossFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProfitAndLossFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProfitAndLossFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProfitAndLossFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProfitAndLossFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProfitAndLossFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProfitAndLossFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProfitAndLossField _setField(
      ProfitAndLossField? field, String colName, DbType dbtype) {
    return ProfitAndLossField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProfitAndLossField? _id;
  ProfitAndLossField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ProfitAndLossField? __periodId;
  ProfitAndLossField get _periodId {
    return __periodId = _setField(__periodId, '_periodId', DbType.integer);
  }

  ProfitAndLossField? _revenue;
  ProfitAndLossField get revenue {
    return _revenue = _setField(_revenue, 'revenue', DbType.real);
  }

  ProfitAndLossField? _cost;
  ProfitAndLossField get cost {
    return _cost = _setField(_cost, 'cost', DbType.real);
  }

  ProfitAndLossField? _expense;
  ProfitAndLossField get expense {
    return _expense = _setField(_expense, 'expense', DbType.real);
  }

  ProfitAndLossField? _profit;
  ProfitAndLossField get profit {
    return _profit = _setField(_profit, 'profit', DbType.real);
  }

  ProfitAndLossField? _date;
  ProfitAndLossField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  ProfitAndLossField? _isDeleted;
  ProfitAndLossField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<ProfitAndLoss> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProfitAndLoss!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProfitAndLoss!.delete(qparams);
    }
    return r;
  }

  /// Recover List<ProfitAndLoss> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover ProfitAndLoss bulk invoked');
    return _mnProfitAndLoss!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from profitAndLoss ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProfitAndLoss!.updateBatch(qparams, values);
  }

  /// This method always returns [ProfitAndLoss] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProfitAndLoss?
  @override
  Future<ProfitAndLoss?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProfitAndLoss!.toList(qparams);
    final data = await objFuture;
    ProfitAndLoss? obj;
    if (data.isNotEmpty) {
      obj = ProfitAndLoss.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ProfitAndLoss]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProfitAndLoss?
  @override
  Future<ProfitAndLoss> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ProfitAndLoss();
  }

  /// This method returns int. [ProfitAndLoss]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? profitandlossCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final profitandlossesFuture = await _mnProfitAndLoss!.toList(qparams);
    final int count = profitandlossesFuture[0]['CNT'] as int;
    if (profitandlossCount != null) {
      profitandlossCount(count);
    }
    return count;
  }

  /// This method returns List<ProfitAndLoss> [ProfitAndLoss]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ProfitAndLoss>
  @override
  Future<List<ProfitAndLoss>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ProfitAndLoss> profitandlossesData =
        await ProfitAndLoss.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return profitandlossesData;
  }

  /// This method returns Json String [ProfitAndLoss]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ProfitAndLoss]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ProfitAndLoss]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProfitAndLoss!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ProfitAndLoss]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM profitAndLoss WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnProfitAndLoss!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ProfitAndLoss]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProfitAndLoss!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ProfitAndLoss.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProfitAndLoss!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProfitAndLossFilterBuilder

// region ProfitAndLossFields
class ProfitAndLossFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fRevenue;
  static TableField get revenue {
    return _fRevenue =
        _fRevenue ?? SqlSyntax.setField(_fRevenue, 'revenue', DbType.real);
  }

  static TableField? _fCost;
  static TableField get cost {
    return _fCost = _fCost ?? SqlSyntax.setField(_fCost, 'cost', DbType.real);
  }

  static TableField? _fExpense;
  static TableField get expense {
    return _fExpense =
        _fExpense ?? SqlSyntax.setField(_fExpense, 'expense', DbType.real);
  }

  static TableField? _fProfit;
  static TableField get profit {
    return _fProfit =
        _fProfit ?? SqlSyntax.setField(_fProfit, 'profit', DbType.real);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ProfitAndLossFields

//region ProfitAndLossManager
class ProfitAndLossManager extends SqfEntityProvider {
  ProfitAndLossManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'profitAndLoss';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProfitAndLossManager
// region User
class User extends TableBase {
  User(
      {this.id,
      this.username,
      this.password,
      this.email,
      this.firstName,
      this.lastName,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  User.withFields(this.username, this.password, this.email, this.firstName,
      this.lastName, this.isDeleted) {
    _setDefaultValues();
  }
  User.withId(this.id, this.username, this.password, this.email, this.firstName,
      this.lastName, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  User.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['username'] != null) {
      username = o['username'].toString();
    }
    if (o['password'] != null) {
      password = o['password'].toString();
    }
    if (o['email'] != null) {
      email = o['email'].toString();
    }
    if (o['firstName'] != null) {
      firstName = o['firstName'].toString();
    }
    if (o['lastName'] != null) {
      lastName = o['lastName'].toString();
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (User)
  int? id;
  String? username;
  String? password;
  String? email;
  String? firstName;
  String? lastName;
  bool? isDeleted;

  // end FIELDS (User)

  static const bool _softDeleteActivated = true;
  UserManager? __mnUser;

  UserManager get _mnUser {
    return __mnUser = __mnUser ?? UserManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (username != null || !forView) {
      map['username'] = username;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (firstName != null || !forView) {
      map['firstName'] = firstName;
    }
    if (lastName != null || !forView) {
      map['lastName'] = lastName;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (username != null || !forView) {
      map['username'] = username;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (firstName != null || !forView) {
      map['firstName'] = firstName;
    }
    if (lastName != null || !forView) {
      map['lastName'] = lastName;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [User]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [User]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [username, password, email, firstName, lastName, isDeleted];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, username, password, email, firstName, lastName, isDeleted];
  }

  static Future<List<User>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<User>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <User>[];
    try {
      objList = list
          .map((user) => User.fromMap(user as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<User>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<User> objList = <User>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = User.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns User by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [User] if exist, otherwise returns null
  Future<User?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    User? obj;
    final data = await _mnUser.getById([id]);
    if (data.length != 0) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUser.insert(this, ignoreBatch);
    } else {
      await _mnUser.update(this);
    }

    return id;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUser.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUser.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs User. Returns a new Primary Key value of User

  /// <returns>Returns a new Primary Key value of User
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<User> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<User> users,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SalesSafeDbModel().batchStart();
    for (final obj in users) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SalesSafeDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < users.length; i++) {
        if (users[i].id == null) {
          users[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUser.rawInsert(
          'INSERT OR REPLACE INTO users (id, username, password, email, firstName, lastName,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [id, username, password, email, firstName, lastName, isDeleted],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'User id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'User id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'User Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<User>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<User> users,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnUser.rawInsertAll(
        'INSERT OR REPLACE INTO users (id, username, password, email, firstName, lastName,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        users,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes User

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete User invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnUser
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUser.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover User

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover User invoked (id=$id)');
    {
      return _mnUser.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  UserFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  UserFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion user

// region UserField
class UserField extends FilterBase {
  UserField(UserFilterBuilder userFB) : super(userFB);

  @override
  UserFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder isNull() {
    return super.isNull() as UserFilterBuilder;
  }

  @override
  UserFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as UserFilterBuilder;
  }

  @override
  UserField get not {
    return super.not as UserField;
  }
}
// endregion UserField

// region UserFilterBuilder
class UserFilterBuilder extends ConjunctionBase {
  UserFilterBuilder(User obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnUser = obj._mnUser;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  UserManager? _mnUser;

  /// put the sql keyword 'AND'
  @override
  UserFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  UserFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  UserFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  UserFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  UserFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  UserFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  UserFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  UserField _setField(UserField? field, String colName, DbType dbtype) {
    return UserField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  UserField? _id;
  UserField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  UserField? _username;
  UserField get username {
    return _username = _setField(_username, 'username', DbType.text);
  }

  UserField? _password;
  UserField get password {
    return _password = _setField(_password, 'password', DbType.text);
  }

  UserField? _email;
  UserField get email {
    return _email = _setField(_email, 'email', DbType.text);
  }

  UserField? _firstName;
  UserField get firstName {
    return _firstName = _setField(_firstName, 'firstName', DbType.text);
  }

  UserField? _lastName;
  UserField get lastName {
    return _lastName = _setField(_lastName, 'lastName', DbType.text);
  }

  UserField? _isDeleted;
  UserField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<User> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUser!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUser!.delete(qparams);
    }
    return r;
  }

  /// Recover List<User> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover User bulk invoked');
    return _mnUser!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from users ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUser!.updateBatch(qparams, values);
  }

  /// This method always returns [User] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User?
  @override
  Future<User?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUser!.toList(qparams);
    final data = await objFuture;
    User? obj;
    if (data.isNotEmpty) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [User]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User?
  @override
  Future<User> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        User();
  }

  /// This method returns int. [User]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? userCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final usersFuture = await _mnUser!.toList(qparams);
    final int count = usersFuture[0]['CNT'] as int;
    if (userCount != null) {
      userCount(count);
    }
    return count;
  }

  /// This method returns List<User> [User]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<User>
  @override
  Future<List<User>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<User> usersData = await User.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return usersData;
  }

  /// This method returns Json String [User]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [User]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [User]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUser!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [User]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM users WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnUser!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [User]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUser!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await User.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUser!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UserFilterBuilder

// region UserFields
class UserFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fUsername;
  static TableField get username {
    return _fUsername =
        _fUsername ?? SqlSyntax.setField(_fUsername, 'username', DbType.text);
  }

  static TableField? _fPassword;
  static TableField get password {
    return _fPassword =
        _fPassword ?? SqlSyntax.setField(_fPassword, 'password', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'email', DbType.text);
  }

  static TableField? _fFirstName;
  static TableField get firstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'firstName', DbType.text);
  }

  static TableField? _fLastName;
  static TableField get lastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'lastName', DbType.text);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion UserFields

//region UserManager
class UserManager extends SqfEntityProvider {
  UserManager()
      : super(SalesSafeDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'users';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UserManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await SalesSafeDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await SalesSafeDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await SalesSafeDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class SalesSafeDbModelSequenceManager extends SqfEntityProvider {
  SalesSafeDbModelSequenceManager() : super(SalesSafeDbModel());
}
// END OF ENTITIES
